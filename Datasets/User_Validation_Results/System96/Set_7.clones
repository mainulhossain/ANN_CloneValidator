$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834426
net/sf/varscan/FilterSomatic.java 165 181
net/sf/varscan/CopyCaller.java 186 200
----------------------------------------
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;
			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
	    		}
		    	catch(Exception e)
		    	{

		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834420
net/sf/varscan/CallMpileup.java 233 249
net/sf/varscan/CopyCaller.java 186 200
----------------------------------------
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;
			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
	    		}
		    	catch(Exception e)
		    	{

		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834425
net/sf/varscan/Somatic.java 255 271
net/sf/varscan/CopyCaller.java 186 200
----------------------------------------
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;
			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
	    		}
		    	catch(Exception e)
		    	{

		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834429
net/sf/varscan/FilterSomatic.java 166 175
net/sf/varscan/CopyCaller.java 187 195
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;
			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834706
net/sf/varscan/ReadCounts.java 126 134
net/sf/varscan/CopyCaller.java 187 195
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;
			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
	    		}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;
			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834428
net/sf/varscan/CallPileup.java 142 151
net/sf/varscan/CopyCaller.java 187 195
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;
			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834703
net/sf/varscan/VarScan.java 519 529
net/sf/varscan/CopyCaller.java 187 195
----------------------------------------
	    		{
	    			System.err.println("Input stream not ready, waiting for 5 seconds...");
	    			Thread.sleep(5000);
	    			num_naps++;

	    			if(num_naps >= 100)
	    			{
	    				System.err.println("ERROR: Gave up waiting after 500 seconds...\n");
	    				System.exit(10);
	    			}
	    		}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;
			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834702
net/sf/varscan/Coverage.java 112 121
net/sf/varscan/CopyCaller.java 187 195
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 10)
			    	{
			    		System.err.println("Input file was not ready after 10 5-second cycles!");
			    		return;
			    	}
		    	}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;
			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834700
net/sf/varscan/CallMpileup.java 234 243
net/sf/varscan/CopyCaller.java 187 195
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;
			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834701
net/sf/varscan/Somatic.java 256 265
net/sf/varscan/CopyCaller.java 187 195
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;
			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834705
net/sf/varscan/Somatic.java 965 974
net/sf/varscan/CopyCaller.java 187 195
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file(s) were not ready for parsing after 100 5-second cycles! Pileup output may be invalid or too slow");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;
			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834704
net/sf/varscan/ProcessSomatic.java 80 89
net/sf/varscan/CopyCaller.java 187 195
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;
			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834432
net/sf/varscan/LimitVariants.java 225 300
net/sf/varscan/Coverage.java 327 421
----------------------------------------
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;
	    		String[] lineContents = line.split("\t");

	    		if(line.substring(0, 1).equals("#"))
	    		{
	    			// Ignore VCF headers //
	    		}
	    		else if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}

----------------------------------------
	{
		HashMap<String, BitSet> positionsByChrom = new HashMap<String, BitSet>();

		int numRegions = 0;
		int numBases = 0;

		try
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
    						numRegions++;

	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						if(!refPositions.get(position))
	    						{
	    							numBases++;
	    							refPositions.set(position, true);
	    						}
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}
		catch(Exception e)
		{
			System.err.println("ERROR: File Parsing Exception: " + e.getLocalizedMessage());
			e.printStackTrace(System.err);
		}

		System.err.println(numRegions + " regions parsed");
		System.err.println(numBases + " unique positions targeted");
		return(positionsByChrom);
	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834433
net/sf/varscan/LimitVariants.java 221 309
net/sf/varscan/Coverage.java 327 421
----------------------------------------
	{
		HashMap<String, BitSet> positionsByChrom = new HashMap<String, BitSet>();

		try
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;
	    		String[] lineContents = line.split("\t");

	    		if(line.substring(0, 1).equals("#"))
	    		{
	    			// Ignore VCF headers //
	    		}
	    		else if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}
		catch(Exception e)
		{
			System.err.println("ERROR: File Parsing Exception: " + e.getLocalizedMessage());
			e.printStackTrace(System.err);
		}


		return(positionsByChrom);
	}

----------------------------------------
	{
		HashMap<String, BitSet> positionsByChrom = new HashMap<String, BitSet>();

		int numRegions = 0;
		int numBases = 0;

		try
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
    						numRegions++;

	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						if(!refPositions.get(position))
	    						{
	    							numBases++;
	    							refPositions.set(position, true);
	    						}
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}
		catch(Exception e)
		{
			System.err.println("ERROR: File Parsing Exception: " + e.getLocalizedMessage());
			e.printStackTrace(System.err);
		}

		System.err.println(numRegions + " regions parsed");
		System.err.println(numBases + " unique positions targeted");
		return(positionsByChrom);
	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834434
net/sf/varscan/ProcessSomatic.java 346 430
net/sf/varscan/Coverage.java 327 421
----------------------------------------
	{
		HashMap<String, BitSet> positionsByChrom = new HashMap<String, BitSet>();

		try
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}
		catch(Exception e)
		{
			System.err.println("ERROR: File Parsing Exception: " + e.getLocalizedMessage());
			e.printStackTrace(System.err);
		}


		return(positionsByChrom);
	}

----------------------------------------
	{
		HashMap<String, BitSet> positionsByChrom = new HashMap<String, BitSet>();

		int numRegions = 0;
		int numBases = 0;

		try
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
    						numRegions++;

	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						if(!refPositions.get(position))
	    						{
	    							numBases++;
	    							refPositions.set(position, true);
	    						}
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}
		catch(Exception e)
		{
			System.err.println("ERROR: File Parsing Exception: " + e.getLocalizedMessage());
			e.printStackTrace(System.err);
		}

		System.err.println(numRegions + " regions parsed");
		System.err.println(numBases + " unique positions targeted");
		return(positionsByChrom);
	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834431
net/sf/varscan/ProcessSomatic.java 350 421
net/sf/varscan/Coverage.java 327 421
----------------------------------------
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}

----------------------------------------
	{
		HashMap<String, BitSet> positionsByChrom = new HashMap<String, BitSet>();

		int numRegions = 0;
		int numBases = 0;

		try
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
    						numRegions++;

	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						if(!refPositions.get(position))
	    						{
	    							numBases++;
	    							refPositions.set(position, true);
	    						}
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}
		catch(Exception e)
		{
			System.err.println("ERROR: File Parsing Exception: " + e.getLocalizedMessage());
			e.printStackTrace(System.err);
		}

		System.err.println(numRegions + " regions parsed");
		System.err.println(numBases + " unique positions targeted");
		return(positionsByChrom);
	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834436
net/sf/varscan/ProcessSomatic.java 350 421
net/sf/varscan/Coverage.java 334 411
----------------------------------------
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}

----------------------------------------
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
    						numRegions++;

	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						if(!refPositions.get(position))
	    						{
	    							numBases++;
	    							refPositions.set(position, true);
	    						}
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834482
net/sf/varscan/ProcessSomatic.java 346 430
net/sf/varscan/Coverage.java 334 411
----------------------------------------
	{
		HashMap<String, BitSet> positionsByChrom = new HashMap<String, BitSet>();

		try
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}
		catch(Exception e)
		{
			System.err.println("ERROR: File Parsing Exception: " + e.getLocalizedMessage());
			e.printStackTrace(System.err);
		}


		return(positionsByChrom);
	}

----------------------------------------
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
    						numRegions++;

	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						if(!refPositions.get(position))
	    						{
	    							numBases++;
	    							refPositions.set(position, true);
	    						}
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834439
net/sf/varscan/ProcessSomatic.java 357 418
net/sf/varscan/Coverage.java 334 411
----------------------------------------
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

----------------------------------------
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
    						numRegions++;

	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						if(!refPositions.get(position))
	    						{
	    							numBases++;
	    							refPositions.set(position, true);
	    						}
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834437
net/sf/varscan/LimitVariants.java 225 300
net/sf/varscan/Coverage.java 334 411
----------------------------------------
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;
	    		String[] lineContents = line.split("\t");

	    		if(line.substring(0, 1).equals("#"))
	    		{
	    			// Ignore VCF headers //
	    		}
	    		else if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}

----------------------------------------
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
    						numRegions++;

	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						if(!refPositions.get(position))
	    						{
	    							numBases++;
	    							refPositions.set(position, true);
	    						}
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834480
net/sf/varscan/ProcessSomatic.java 362 417
net/sf/varscan/Coverage.java 334 411
----------------------------------------
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}

----------------------------------------
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
    						numRegions++;

	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						if(!refPositions.get(position))
	    						{
	    							numBases++;
	    							refPositions.set(position, true);
	    						}
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834481
net/sf/varscan/LimitVariants.java 221 309
net/sf/varscan/Coverage.java 334 411
----------------------------------------
	{
		HashMap<String, BitSet> positionsByChrom = new HashMap<String, BitSet>();

		try
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;
	    		String[] lineContents = line.split("\t");

	    		if(line.substring(0, 1).equals("#"))
	    		{
	    			// Ignore VCF headers //
	    		}
	    		else if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}
		catch(Exception e)
		{
			System.err.println("ERROR: File Parsing Exception: " + e.getLocalizedMessage());
			e.printStackTrace(System.err);
		}


		return(positionsByChrom);
	}

----------------------------------------
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
    						numRegions++;

	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						if(!refPositions.get(position))
	    						{
	    							numBases++;
	    							refPositions.set(position, true);
	    						}
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834435
net/sf/varscan/LimitVariants.java 241 296
net/sf/varscan/Coverage.java 334 411
----------------------------------------
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}

----------------------------------------
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
    						numRegions++;

	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						if(!refPositions.get(position))
	    						{
	    							numBases++;
	    							refPositions.set(position, true);
	    						}
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834438
net/sf/varscan/LimitVariants.java 232 297
net/sf/varscan/Coverage.java 334 411
----------------------------------------
	    	{
	    		lineCounter++;
	    		String[] lineContents = line.split("\t");

	    		if(line.substring(0, 1).equals("#"))
	    		{
	    			// Ignore VCF headers //
	    		}
	    		else if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

----------------------------------------
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
    						numRegions++;

	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						if(!refPositions.get(position))
	    						{
	    							numBases++;
	    							refPositions.set(position, true);
	    						}
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834516
net/sf/varscan/Copynumber.java 619 627
net/sf/varscan/Copynumber.java 652 660
----------------------------------------
		    {
		    	String[] normalContents = lineNormal.split("\t");

		    	if(normalContents.length > 1)
		    	{
			    	chromNormal = normalContents[0];
			    	posNormal = Integer.parseInt(normalContents[1]);
		    	}
		    }

----------------------------------------
		    		{
		    			String[] normalContents = lineNormal.split("\t");

				    	if(normalContents.length > 1)
				    	{
					    	chromNormal = normalContents[0];
					    	posNormal = Integer.parseInt(normalContents[1]);
				    	}
		    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834518
net/sf/varscan/Somatic.java 1039 1047
net/sf/varscan/Copynumber.java 652 660
----------------------------------------
		    		{
		    			String[] normalContents = lineNormal.split("\t");

				    	if(normalContents.length > 1)
				    	{
					    	chromNormal = normalContents[0];
					    	posNormal = Integer.parseInt(normalContents[1]);
				    	}
		    		}

----------------------------------------
		    		{
		    			String[] normalContents = lineNormal.split("\t");

				    	if(normalContents.length > 1)
				    	{
					    	chromNormal = normalContents[0];
					    	posNormal = Integer.parseInt(normalContents[1]);
				    	}
		    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834440
net/sf/varscan/Copynumber.java 713 720
net/sf/varscan/Copynumber.java 652 660
----------------------------------------
		    		{
		    			tumorContents = lineTumor.split("\t");
				    	if(tumorContents.length > 1)
				    	{
					    	chromTumor = tumorContents[0];
					    	posTumor = Integer.parseInt(tumorContents[1]);
				    	}
		    		}

----------------------------------------
		    		{
		    			String[] normalContents = lineNormal.split("\t");

				    	if(normalContents.length > 1)
				    	{
					    	chromNormal = normalContents[0];
					    	posNormal = Integer.parseInt(normalContents[1]);
				    	}
		    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834515
net/sf/varscan/Somatic.java 1063 1070
net/sf/varscan/Copynumber.java 652 660
----------------------------------------
		    		{
		    			String[] normalContents = lineNormal.split("\t");
				    	if(normalContents.length > 1)
				    	{
					    	chromNormal = normalContents[0];
					    	posNormal = Integer.parseInt(normalContents[1]);
				    	}
		    		}

----------------------------------------
		    		{
		    			String[] normalContents = lineNormal.split("\t");

				    	if(normalContents.length > 1)
				    	{
					    	chromNormal = normalContents[0];
					    	posNormal = Integer.parseInt(normalContents[1]);
				    	}
		    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834513
net/sf/varscan/Somatic.java 1075 1082
net/sf/varscan/Copynumber.java 652 660
----------------------------------------
		    		{
		    			tumorContents = lineTumor.split("\t");
				    	if(tumorContents.length > 1)
				    	{
					    	chromTumor = tumorContents[0];
					    	posTumor = Integer.parseInt(tumorContents[1]);
				    	}
		    		}

----------------------------------------
		    		{
		    			String[] normalContents = lineNormal.split("\t");

				    	if(normalContents.length > 1)
				    	{
					    	chromNormal = normalContents[0];
					    	posNormal = Integer.parseInt(normalContents[1]);
				    	}
		    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834514
net/sf/varscan/Somatic.java 1006 1014
net/sf/varscan/Copynumber.java 652 660
----------------------------------------
		    {
		    	String[] normalContents = lineNormal.split("\t");

		    	if(normalContents.length > 1)
		    	{
			    	chromNormal = normalContents[0];
			    	posNormal = Integer.parseInt(normalContents[1]);
		    	}
		    }

----------------------------------------
		    		{
		    			String[] normalContents = lineNormal.split("\t");

				    	if(normalContents.length > 1)
				    	{
					    	chromNormal = normalContents[0];
					    	posNormal = Integer.parseInt(normalContents[1]);
				    	}
		    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834517
net/sf/varscan/Somatic.java 1406 1414
net/sf/varscan/Copynumber.java 652 660
----------------------------------------
		    			{
			    			tumorContents = lineTumor.split("\t");

					    	if(tumorContents.length > 1)
					    	{
						    	chromTumor = tumorContents[0];
						    	posTumor = Integer.parseInt(tumorContents[1]);
					    	}
		    			}

----------------------------------------
		    		{
		    			String[] normalContents = lineNormal.split("\t");

				    	if(normalContents.length > 1)
				    	{
					    	chromNormal = normalContents[0];
					    	posNormal = Integer.parseInt(normalContents[1]);
				    	}
		    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834442
net/sf/varscan/Copynumber.java 206 380
net/sf/varscan/Copynumber.java 725 901
----------------------------------------
	    			{
	    				String[] lineContents = line.split("\t");

	    				// Verify expected pileup format //

	    				if(lineContents.length > 5 && lineContents[0].length() > 0 && lineContents[1].length() > 0 && lineContents[2].length() > 0 && lineContents[3].length() > 0)
	    				{
	    					sharedPositions++;

	    					// Parse common fields from line //
	    					String refName = lineContents[0];
	    					int position = Integer.parseInt(lineContents[1]);
	    					refBase = lineContents[2].toUpperCase();

	    					chromNormal = refName;
	    					chromTumor = refName;
	    					posNormal = position;
	    					posTumor = position;

	    					// Parse normal, which should be first sample //
	    					int normalOffset = 3;
	    					int pileupDepthNormal = Integer.parseInt(lineContents[normalOffset]);
		    	        	//String normalBases = lineContents[normalOffset + 1];
		    	        	String normalQualities = lineContents[normalOffset + 2];

	    					// Parse tumor, which should be second sample //
	    					int tumorOffset = 6;
	    					int pileupDepthTumor = Integer.parseInt(lineContents[tumorOffset]);
		    	        	//String tumorBases = lineContents[tumorOffset + 1];
		    	        	String tumorQualities = lineContents[tumorOffset + 2];


		    	        	// If either sample met the minimum coverage and both had at least one read //

//		    	        	if((pileupDepthNormal >= minCoverage || pileupDepthTumor >= minCoverage) && normalQualities.length() > 0)// && tumorQualities.length() > 0)

		    	        	// We want the normal sample to meet the minimum coverage because that's the comparator //
		    	        	if(pileupDepthNormal >= minCoverage && normalQualities.length() > 0)// && tumorQualities.length() > 0)
	    					{
	    						comparedPositions++;
	    						// Get the depth of bases above minimum quality //

	    	    				int normalDepth = VarScan.qualityDepth(normalQualities, minBaseQual);
	    	    				int tumorDepth = 0;
	    	    				if(tumorQualities.length() > 0)
	    	    					tumorDepth = VarScan.qualityDepth(tumorQualities, minBaseQual);

	    	    				// Determine if we have a copy changepoint //
	    	    				// If this base is not contiguous with the copyRegion
	    	    				// If the normal or tumor depth changes //

	    	    				int diffNormal = Math.abs(copyDepthNormal - normalDepth);
	    	    				int diffTumor = Math.abs(copyDepthTumor - tumorDepth);
	    	    				int posDiff = posTumor - copyStop;

	    	    				// DETERMINE IF WE CONTINUE THIS REGION OR PROCESS IT AND START A NEW ONE //

	    	    				boolean continueFlag = false;

	    	    				// If chromosomes differ or contiguity broken, process the region //

	    	    				if(posDiff > 2 || !(copyChrom.equals(chromTumor)))
	    	    				{
	    	    					continueFlag = false;
	    	    				}
	    	    				else
	    	    				{
	    	    					if(copyPositions >= maxSegmentSize)
	    	    					{
	    	    						continueFlag = false;
	    	    					}
	    	    					else if(diffNormal <= 2 && diffTumor <= 2)
	    	    					{
	    	    						continueFlag = true;
	    	    					}
	    	    					else
	    	    					{
	    	    						// Do a Fisher's exact test on the copy number changes. ##

	        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

	        	    					// If depth change not significant, continue with region //
	        	    					if(changePvalue >= pValueThreshold)
	        	    					{
	        	    						continueFlag = true;
	        	    					}
	        	    					else
	        	    					{
	        	    						continueFlag = false;
	        	    					}

	    	    					}
	    	    				}


	    	    				// If continuing, extend this region and don't process yet //

	    	    				if(continueFlag)
	    	    				{
	    	    					copySumNormal += normalDepth;
	    	    					copySumTumor += tumorDepth;
	    	    					copyPositions++;
	    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
	    	    						copyPositionsGC++;
	    	    					copyStop = posTumor;
	    	    				}

	    	    				// Otherwise, process this region (if it qualifies) and start a new one //

	    	    				else
	    	    				{
	    	    					if(copyPositions >= minSegmentSize)
	    	    					{
	    	    						rawCopySegments++;
	    	    						String regionResults = processCopyRegion(copyChrom, copyStart, copyStop, copyPositions, copyPositionsGC, copySumNormal, copySumTumor, minCoverage, dataRatio);

	    	    						if(regionResults.length() > 0)
	    	    						{
	    	    							outCopySegments.println(regionResults);
	    	    							goodCopySegments++;
	    	    						}
	    	    					}

	    	    					// Start a new copyNumber region //
	    	    					copyChrom = chromTumor;
	    	    					copyStart = posTumor;
	    	    					copyStop = posTumor;
	    	    					copyDepthNormal = normalDepth;
	    	    					copyDepthTumor = tumorDepth;
	    	    					copySumNormal = normalDepth;
	    	    					copySumTumor = tumorDepth;
	    	    					copyPositions = 1;
	    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
	    	    						copyPositionsGC = 1;
	    	    					else
	    	    						copyPositionsGC = 0;
	    	    				}


	    					}
	    					else
	    					{
	    						// If minimum coverage was not met, print region //
		    					// If we had a copyNumber region that met minimum coverage, report it //
		    					if(copyPositions >= minSegmentSize)
		    					{
		    						rawCopySegments++;
		    						String regionResults = processCopyRegion(copyChrom, copyStart, copyStop, copyPositions, copyPositionsGC, copySumNormal, copySumTumor, minCoverage, dataRatio);

		    						if(regionResults.length() > 0)
		    						{
		    							outCopySegments.println(regionResults);
		    							goodCopySegments++;
		    						}
		    					}

		    					// Reset the copyNumber region //
		    					copyChrom = "";
		    					copyStart = 0;
		    					copyStop = 0;
		    					copyDepthNormal = 0;
		    					copyDepthTumor = 0;
		    					copySumNormal = 0;
		    					copySumTumor = 0;
		    					copyPositions = 0;
		    					copyPositionsGC = 0;
	    					}

	    				}
	    				else
	    				{
	    					System.err.println("Error: Invalid format or not enough samples in mpileup: " + line + "\n");
	    					return;
	    				}
	    			}

----------------------------------------
		    		{
		    			//stats.put("sharedPositions", (stats.get("sharedPositions") + 1));
		    			sharedPositions++;
		    			refBase = tumorContents[2];

//		    			 Parse out base qualities //
	    				String[] normalContents = lineNormal.split("\t");
	    				int pileupDepthNormal = 0;
	    				int pileupDepthTumor = 0;
	    				String normalQualities = "";
	    				String tumorQualities = "";

	    				// Pileup Files have 6-7 columns //
    					if(normalContents.length >= 6 && normalContents.length <= 7)
    					{
    						pileupDepthNormal = Integer.parseInt(normalContents[3]);
    						normalQualities = normalContents[5];
    					}
    					// Pileup lines in CNS files have 10-11 columns
    					else if (normalContents.length >= 10 && normalContents.length <= 11)
    					{
    						pileupDepthNormal = Integer.parseInt(normalContents[7]);
    						normalQualities = normalContents[9];
    					}

	    				// Pileup Files have 6-7 columns //
    					if(tumorContents.length >= 6 && tumorContents.length <= 7)
    					{
    						tumorQualities = tumorContents[5];
    						pileupDepthTumor = Integer.parseInt(tumorContents[3]);
    					}
    					// Pileup lines in CNS files have 10-11 columns
    					else if (tumorContents.length >= 10 && tumorContents.length <= 11)
    					{
    						tumorQualities = tumorContents[9];
    						pileupDepthTumor = Integer.parseInt(tumorContents[7]);
    					}

    					// If either sample met the minimum coverage and both had at least one read //

//    					if((pileupDepthNormal >= minCoverage || pileupDepthTumor >= minCoverage) && normalQualities.length() > 0 && tumorQualities.length() > 0)

    					// We want the normal sample to meet the minimum coverage because that's the comparator //
    					if(pileupDepthNormal >= minCoverage && normalQualities.length() > 0) // && tumorQualities.length() > 0)
    					{
    						comparedPositions++;
//    						 Get the depth of bases above minimum quality //

    	    				int normalDepth = VarScan.qualityDepth(normalQualities, minBaseQual);
    	    				int tumorDepth = VarScan.qualityDepth(tumorQualities, minBaseQual);

    	    				// Determine if we have a copy changepoint //
    	    				// If this base is not contiguous with the copyRegion
    	    				// If the normal or tumor depth changes //

    	    				int diffNormal = Math.abs(copyDepthNormal - normalDepth);
    	    				int diffTumor = Math.abs(copyDepthTumor - tumorDepth);
    	    				int posDiff = posTumor - copyStop;

    	    				// DETERMINE IF WE CONTINUE THIS REGION OR PROCESS IT AND START A NEW ONE //

    	    				boolean continueFlag = false;

    	    				// If chromosomes differ or contiguity broken, process the region //

    	    				if(posDiff > 2 || !(copyChrom.equals(chromTumor)))
    	    				{
    	    					continueFlag = false;
    	    				}
    	    				else
    	    				{
    	    					if(copyPositions >= maxSegmentSize)
    	    					{
    	    						continueFlag = false;
    	    					}
    	    					else if(diffNormal <= 2 && diffTumor <= 2)
    	    					{
    	    						continueFlag = true;
    	    					}
    	    					else
    	    					{
    	    						// Do a Fisher's exact test on the copy number changes. ##

        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

        	    					// If depth change not significant, continue with region //
        	    					if(changePvalue >= pValueThreshold)
        	    					{
        	    						continueFlag = true;
        	    					}
        	    					else
        	    					{
        	    						continueFlag = false;
        	    					}

    	    					}
    	    				}


    	    				// If continuing, extend this region and don't process yet //

    	    				if(continueFlag)
    	    				{
    	    					copySumNormal += normalDepth;
    	    					copySumTumor += tumorDepth;
    	    					copyPositions++;
    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
    	    						copyPositionsGC++;
    	    					copyStop = posTumor;
    	    				}

    	    				// Otherwise, process this region (if it qualifies) and start a new one //

    	    				else
    	    				{
    	    					if(copyPositions >= minSegmentSize)
    	    					{
    	    						rawCopySegments++;
    	    						String regionResults = processCopyRegion(copyChrom, copyStart, copyStop, copyPositions, copyPositionsGC, copySumNormal, copySumTumor, minCoverage, dataRatio);

    	    						if(regionResults.length() > 0)
    	    						{
    	    							outCopySegments.println(regionResults);
    	    							goodCopySegments++;
    	    						}
    	    					}

    	    					// Start a new copyNumber region //
    	    					copyChrom = chromTumor;
    	    					copyStart = posTumor;
    	    					copyStop = posTumor;
    	    					copyDepthNormal = normalDepth;
    	    					copyDepthTumor = tumorDepth;
    	    					copySumNormal = normalDepth;
    	    					copySumTumor = tumorDepth;
    	    					copyPositions = 1;
    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
    	    						copyPositionsGC = 1;
    	    					else
    	    						copyPositionsGC = 0;
    	    				}


    					}
    					else
    					{
    						// If minimum coverage was not met, print region //
	    					// If we had a copyNumber region that met minimum coverage, report it //
	    					if(copyPositions >= minSegmentSize)
	    					{
	    						rawCopySegments++;
	    						String regionResults = processCopyRegion(copyChrom, copyStart, copyStop, copyPositions, copyPositionsGC, copySumNormal, copySumTumor, minCoverage, dataRatio);

	    						if(regionResults.length() > 0)
	    						{
	    							outCopySegments.println(regionResults);
	    							goodCopySegments++;
	    						}
	    					}

	    					// Reset the copyNumber region //
	    					copyChrom = "";
	    					copyStart = 0;
	    					copyStop = 0;
	    					copyDepthNormal = 0;
	    					copyDepthTumor = 0;
	    					copySumNormal = 0;
	    					copySumTumor = 0;
	    					copyPositions = 0;
	    					copyPositionsGC = 0;
    					}

	    				// Record this chromosome //

				    	prevChromNormal = chromNormal;
				    	prevChromTumor = chromTumor;
		    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834443
net/sf/varscan/Copynumber.java 725 901
net/sf/varscan/Copynumber.java 212 374
----------------------------------------
		    		{
		    			//stats.put("sharedPositions", (stats.get("sharedPositions") + 1));
		    			sharedPositions++;
		    			refBase = tumorContents[2];

//		    			 Parse out base qualities //
	    				String[] normalContents = lineNormal.split("\t");
	    				int pileupDepthNormal = 0;
	    				int pileupDepthTumor = 0;
	    				String normalQualities = "";
	    				String tumorQualities = "";

	    				// Pileup Files have 6-7 columns //
    					if(normalContents.length >= 6 && normalContents.length <= 7)
    					{
    						pileupDepthNormal = Integer.parseInt(normalContents[3]);
    						normalQualities = normalContents[5];
    					}
    					// Pileup lines in CNS files have 10-11 columns
    					else if (normalContents.length >= 10 && normalContents.length <= 11)
    					{
    						pileupDepthNormal = Integer.parseInt(normalContents[7]);
    						normalQualities = normalContents[9];
    					}

	    				// Pileup Files have 6-7 columns //
    					if(tumorContents.length >= 6 && tumorContents.length <= 7)
    					{
    						tumorQualities = tumorContents[5];
    						pileupDepthTumor = Integer.parseInt(tumorContents[3]);
    					}
    					// Pileup lines in CNS files have 10-11 columns
    					else if (tumorContents.length >= 10 && tumorContents.length <= 11)
    					{
    						tumorQualities = tumorContents[9];
    						pileupDepthTumor = Integer.parseInt(tumorContents[7]);
    					}

    					// If either sample met the minimum coverage and both had at least one read //

//    					if((pileupDepthNormal >= minCoverage || pileupDepthTumor >= minCoverage) && normalQualities.length() > 0 && tumorQualities.length() > 0)

    					// We want the normal sample to meet the minimum coverage because that's the comparator //
    					if(pileupDepthNormal >= minCoverage && normalQualities.length() > 0) // && tumorQualities.length() > 0)
    					{
    						comparedPositions++;
//    						 Get the depth of bases above minimum quality //

    	    				int normalDepth = VarScan.qualityDepth(normalQualities, minBaseQual);
    	    				int tumorDepth = VarScan.qualityDepth(tumorQualities, minBaseQual);

    	    				// Determine if we have a copy changepoint //
    	    				// If this base is not contiguous with the copyRegion
    	    				// If the normal or tumor depth changes //

    	    				int diffNormal = Math.abs(copyDepthNormal - normalDepth);
    	    				int diffTumor = Math.abs(copyDepthTumor - tumorDepth);
    	    				int posDiff = posTumor - copyStop;

    	    				// DETERMINE IF WE CONTINUE THIS REGION OR PROCESS IT AND START A NEW ONE //

    	    				boolean continueFlag = false;

    	    				// If chromosomes differ or contiguity broken, process the region //

    	    				if(posDiff > 2 || !(copyChrom.equals(chromTumor)))
    	    				{
    	    					continueFlag = false;
    	    				}
    	    				else
    	    				{
    	    					if(copyPositions >= maxSegmentSize)
    	    					{
    	    						continueFlag = false;
    	    					}
    	    					else if(diffNormal <= 2 && diffTumor <= 2)
    	    					{
    	    						continueFlag = true;
    	    					}
    	    					else
    	    					{
    	    						// Do a Fisher's exact test on the copy number changes. ##

        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

        	    					// If depth change not significant, continue with region //
        	    					if(changePvalue >= pValueThreshold)
        	    					{
        	    						continueFlag = true;
        	    					}
        	    					else
        	    					{
        	    						continueFlag = false;
        	    					}

    	    					}
    	    				}


    	    				// If continuing, extend this region and don't process yet //

    	    				if(continueFlag)
    	    				{
    	    					copySumNormal += normalDepth;
    	    					copySumTumor += tumorDepth;
    	    					copyPositions++;
    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
    	    						copyPositionsGC++;
    	    					copyStop = posTumor;
    	    				}

    	    				// Otherwise, process this region (if it qualifies) and start a new one //

    	    				else
    	    				{
    	    					if(copyPositions >= minSegmentSize)
    	    					{
    	    						rawCopySegments++;
    	    						String regionResults = processCopyRegion(copyChrom, copyStart, copyStop, copyPositions, copyPositionsGC, copySumNormal, copySumTumor, minCoverage, dataRatio);

    	    						if(regionResults.length() > 0)
    	    						{
    	    							outCopySegments.println(regionResults);
    	    							goodCopySegments++;
    	    						}
    	    					}

    	    					// Start a new copyNumber region //
    	    					copyChrom = chromTumor;
    	    					copyStart = posTumor;
    	    					copyStop = posTumor;
    	    					copyDepthNormal = normalDepth;
    	    					copyDepthTumor = tumorDepth;
    	    					copySumNormal = normalDepth;
    	    					copySumTumor = tumorDepth;
    	    					copyPositions = 1;
    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
    	    						copyPositionsGC = 1;
    	    					else
    	    						copyPositionsGC = 0;
    	    				}


    					}
    					else
    					{
    						// If minimum coverage was not met, print region //
	    					// If we had a copyNumber region that met minimum coverage, report it //
	    					if(copyPositions >= minSegmentSize)
	    					{
	    						rawCopySegments++;
	    						String regionResults = processCopyRegion(copyChrom, copyStart, copyStop, copyPositions, copyPositionsGC, copySumNormal, copySumTumor, minCoverage, dataRatio);

	    						if(regionResults.length() > 0)
	    						{
	    							outCopySegments.println(regionResults);
	    							goodCopySegments++;
	    						}
	    					}

	    					// Reset the copyNumber region //
	    					copyChrom = "";
	    					copyStart = 0;
	    					copyStop = 0;
	    					copyDepthNormal = 0;
	    					copyDepthTumor = 0;
	    					copySumNormal = 0;
	    					copySumTumor = 0;
	    					copyPositions = 0;
	    					copyPositionsGC = 0;
    					}

	    				// Record this chromosome //

				    	prevChromNormal = chromNormal;
				    	prevChromTumor = chromTumor;
		    		}

----------------------------------------
	    				{
	    					sharedPositions++;

	    					// Parse common fields from line //
	    					String refName = lineContents[0];
	    					int position = Integer.parseInt(lineContents[1]);
	    					refBase = lineContents[2].toUpperCase();

	    					chromNormal = refName;
	    					chromTumor = refName;
	    					posNormal = position;
	    					posTumor = position;

	    					// Parse normal, which should be first sample //
	    					int normalOffset = 3;
	    					int pileupDepthNormal = Integer.parseInt(lineContents[normalOffset]);
		    	        	//String normalBases = lineContents[normalOffset + 1];
		    	        	String normalQualities = lineContents[normalOffset + 2];

	    					// Parse tumor, which should be second sample //
	    					int tumorOffset = 6;
	    					int pileupDepthTumor = Integer.parseInt(lineContents[tumorOffset]);
		    	        	//String tumorBases = lineContents[tumorOffset + 1];
		    	        	String tumorQualities = lineContents[tumorOffset + 2];


		    	        	// If either sample met the minimum coverage and both had at least one read //

//		    	        	if((pileupDepthNormal >= minCoverage || pileupDepthTumor >= minCoverage) && normalQualities.length() > 0)// && tumorQualities.length() > 0)

		    	        	// We want the normal sample to meet the minimum coverage because that's the comparator //
		    	        	if(pileupDepthNormal >= minCoverage && normalQualities.length() > 0)// && tumorQualities.length() > 0)
	    					{
	    						comparedPositions++;
	    						// Get the depth of bases above minimum quality //

	    	    				int normalDepth = VarScan.qualityDepth(normalQualities, minBaseQual);
	    	    				int tumorDepth = 0;
	    	    				if(tumorQualities.length() > 0)
	    	    					tumorDepth = VarScan.qualityDepth(tumorQualities, minBaseQual);

	    	    				// Determine if we have a copy changepoint //
	    	    				// If this base is not contiguous with the copyRegion
	    	    				// If the normal or tumor depth changes //

	    	    				int diffNormal = Math.abs(copyDepthNormal - normalDepth);
	    	    				int diffTumor = Math.abs(copyDepthTumor - tumorDepth);
	    	    				int posDiff = posTumor - copyStop;

	    	    				// DETERMINE IF WE CONTINUE THIS REGION OR PROCESS IT AND START A NEW ONE //

	    	    				boolean continueFlag = false;

	    	    				// If chromosomes differ or contiguity broken, process the region //

	    	    				if(posDiff > 2 || !(copyChrom.equals(chromTumor)))
	    	    				{
	    	    					continueFlag = false;
	    	    				}
	    	    				else
	    	    				{
	    	    					if(copyPositions >= maxSegmentSize)
	    	    					{
	    	    						continueFlag = false;
	    	    					}
	    	    					else if(diffNormal <= 2 && diffTumor <= 2)
	    	    					{
	    	    						continueFlag = true;
	    	    					}
	    	    					else
	    	    					{
	    	    						// Do a Fisher's exact test on the copy number changes. ##

	        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

	        	    					// If depth change not significant, continue with region //
	        	    					if(changePvalue >= pValueThreshold)
	        	    					{
	        	    						continueFlag = true;
	        	    					}
	        	    					else
	        	    					{
	        	    						continueFlag = false;
	        	    					}

	    	    					}
	    	    				}


	    	    				// If continuing, extend this region and don't process yet //

	    	    				if(continueFlag)
	    	    				{
	    	    					copySumNormal += normalDepth;
	    	    					copySumTumor += tumorDepth;
	    	    					copyPositions++;
	    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
	    	    						copyPositionsGC++;
	    	    					copyStop = posTumor;
	    	    				}

	    	    				// Otherwise, process this region (if it qualifies) and start a new one //

	    	    				else
	    	    				{
	    	    					if(copyPositions >= minSegmentSize)
	    	    					{
	    	    						rawCopySegments++;
	    	    						String regionResults = processCopyRegion(copyChrom, copyStart, copyStop, copyPositions, copyPositionsGC, copySumNormal, copySumTumor, minCoverage, dataRatio);

	    	    						if(regionResults.length() > 0)
	    	    						{
	    	    							outCopySegments.println(regionResults);
	    	    							goodCopySegments++;
	    	    						}
	    	    					}

	    	    					// Start a new copyNumber region //
	    	    					copyChrom = chromTumor;
	    	    					copyStart = posTumor;
	    	    					copyStop = posTumor;
	    	    					copyDepthNormal = normalDepth;
	    	    					copyDepthTumor = tumorDepth;
	    	    					copySumNormal = normalDepth;
	    	    					copySumTumor = tumorDepth;
	    	    					copyPositions = 1;
	    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
	    	    						copyPositionsGC = 1;
	    	    					else
	    	    						copyPositionsGC = 0;
	    	    				}


	    					}
	    					else
	    					{
	    						// If minimum coverage was not met, print region //
		    					// If we had a copyNumber region that met minimum coverage, report it //
		    					if(copyPositions >= minSegmentSize)
		    					{
		    						rawCopySegments++;
		    						String regionResults = processCopyRegion(copyChrom, copyStart, copyStop, copyPositions, copyPositionsGC, copySumNormal, copySumTumor, minCoverage, dataRatio);

		    						if(regionResults.length() > 0)
		    						{
		    							outCopySegments.println(regionResults);
		    							goodCopySegments++;
		    						}
		    					}

		    					// Reset the copyNumber region //
		    					copyChrom = "";
		    					copyStart = 0;
		    					copyStop = 0;
		    					copyDepthNormal = 0;
		    					copyDepthTumor = 0;
		    					copySumNormal = 0;
		    					copySumTumor = 0;
		    					copyPositions = 0;
		    					copyPositionsGC = 0;
	    					}

	    				}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834444
net/sf/varscan/Copynumber.java 725 901
net/sf/varscan/Copynumber.java 201 394
----------------------------------------
		    		{
		    			//stats.put("sharedPositions", (stats.get("sharedPositions") + 1));
		    			sharedPositions++;
		    			refBase = tumorContents[2];

//		    			 Parse out base qualities //
	    				String[] normalContents = lineNormal.split("\t");
	    				int pileupDepthNormal = 0;
	    				int pileupDepthTumor = 0;
	    				String normalQualities = "";
	    				String tumorQualities = "";

	    				// Pileup Files have 6-7 columns //
    					if(normalContents.length >= 6 && normalContents.length <= 7)
    					{
    						pileupDepthNormal = Integer.parseInt(normalContents[3]);
    						normalQualities = normalContents[5];
    					}
    					// Pileup lines in CNS files have 10-11 columns
    					else if (normalContents.length >= 10 && normalContents.length <= 11)
    					{
    						pileupDepthNormal = Integer.parseInt(normalContents[7]);
    						normalQualities = normalContents[9];
    					}

	    				// Pileup Files have 6-7 columns //
    					if(tumorContents.length >= 6 && tumorContents.length <= 7)
    					{
    						tumorQualities = tumorContents[5];
    						pileupDepthTumor = Integer.parseInt(tumorContents[3]);
    					}
    					// Pileup lines in CNS files have 10-11 columns
    					else if (tumorContents.length >= 10 && tumorContents.length <= 11)
    					{
    						tumorQualities = tumorContents[9];
    						pileupDepthTumor = Integer.parseInt(tumorContents[7]);
    					}

    					// If either sample met the minimum coverage and both had at least one read //

//    					if((pileupDepthNormal >= minCoverage || pileupDepthTumor >= minCoverage) && normalQualities.length() > 0 && tumorQualities.length() > 0)

    					// We want the normal sample to meet the minimum coverage because that's the comparator //
    					if(pileupDepthNormal >= minCoverage && normalQualities.length() > 0) // && tumorQualities.length() > 0)
    					{
    						comparedPositions++;
//    						 Get the depth of bases above minimum quality //

    	    				int normalDepth = VarScan.qualityDepth(normalQualities, minBaseQual);
    	    				int tumorDepth = VarScan.qualityDepth(tumorQualities, minBaseQual);

    	    				// Determine if we have a copy changepoint //
    	    				// If this base is not contiguous with the copyRegion
    	    				// If the normal or tumor depth changes //

    	    				int diffNormal = Math.abs(copyDepthNormal - normalDepth);
    	    				int diffTumor = Math.abs(copyDepthTumor - tumorDepth);
    	    				int posDiff = posTumor - copyStop;

    	    				// DETERMINE IF WE CONTINUE THIS REGION OR PROCESS IT AND START A NEW ONE //

    	    				boolean continueFlag = false;

    	    				// If chromosomes differ or contiguity broken, process the region //

    	    				if(posDiff > 2 || !(copyChrom.equals(chromTumor)))
    	    				{
    	    					continueFlag = false;
    	    				}
    	    				else
    	    				{
    	    					if(copyPositions >= maxSegmentSize)
    	    					{
    	    						continueFlag = false;
    	    					}
    	    					else if(diffNormal <= 2 && diffTumor <= 2)
    	    					{
    	    						continueFlag = true;
    	    					}
    	    					else
    	    					{
    	    						// Do a Fisher's exact test on the copy number changes. ##

        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

        	    					// If depth change not significant, continue with region //
        	    					if(changePvalue >= pValueThreshold)
        	    					{
        	    						continueFlag = true;
        	    					}
        	    					else
        	    					{
        	    						continueFlag = false;
        	    					}

    	    					}
    	    				}


    	    				// If continuing, extend this region and don't process yet //

    	    				if(continueFlag)
    	    				{
    	    					copySumNormal += normalDepth;
    	    					copySumTumor += tumorDepth;
    	    					copyPositions++;
    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
    	    						copyPositionsGC++;
    	    					copyStop = posTumor;
    	    				}

    	    				// Otherwise, process this region (if it qualifies) and start a new one //

    	    				else
    	    				{
    	    					if(copyPositions >= minSegmentSize)
    	    					{
    	    						rawCopySegments++;
    	    						String regionResults = processCopyRegion(copyChrom, copyStart, copyStop, copyPositions, copyPositionsGC, copySumNormal, copySumTumor, minCoverage, dataRatio);

    	    						if(regionResults.length() > 0)
    	    						{
    	    							outCopySegments.println(regionResults);
    	    							goodCopySegments++;
    	    						}
    	    					}

    	    					// Start a new copyNumber region //
    	    					copyChrom = chromTumor;
    	    					copyStart = posTumor;
    	    					copyStop = posTumor;
    	    					copyDepthNormal = normalDepth;
    	    					copyDepthTumor = tumorDepth;
    	    					copySumNormal = normalDepth;
    	    					copySumTumor = tumorDepth;
    	    					copyPositions = 1;
    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
    	    						copyPositionsGC = 1;
    	    					else
    	    						copyPositionsGC = 0;
    	    				}


    					}
    					else
    					{
    						// If minimum coverage was not met, print region //
	    					// If we had a copyNumber region that met minimum coverage, report it //
	    					if(copyPositions >= minSegmentSize)
	    					{
	    						rawCopySegments++;
	    						String regionResults = processCopyRegion(copyChrom, copyStart, copyStop, copyPositions, copyPositionsGC, copySumNormal, copySumTumor, minCoverage, dataRatio);

	    						if(regionResults.length() > 0)
	    						{
	    							outCopySegments.println(regionResults);
	    							goodCopySegments++;
	    						}
	    					}

	    					// Reset the copyNumber region //
	    					copyChrom = "";
	    					copyStart = 0;
	    					copyStop = 0;
	    					copyDepthNormal = 0;
	    					copyDepthTumor = 0;
	    					copySumNormal = 0;
	    					copySumTumor = 0;
	    					copyPositions = 0;
	    					copyPositionsGC = 0;
    					}

	    				// Record this chromosome //

				    	prevChromNormal = chromNormal;
				    	prevChromTumor = chromTumor;
		    		}

----------------------------------------
	    		{

	    			// Begin try-catch for line parsing //

	    			try
	    			{
	    				String[] lineContents = line.split("\t");

	    				// Verify expected pileup format //

	    				if(lineContents.length > 5 && lineContents[0].length() > 0 && lineContents[1].length() > 0 && lineContents[2].length() > 0 && lineContents[3].length() > 0)
	    				{
	    					sharedPositions++;

	    					// Parse common fields from line //
	    					String refName = lineContents[0];
	    					int position = Integer.parseInt(lineContents[1]);
	    					refBase = lineContents[2].toUpperCase();

	    					chromNormal = refName;
	    					chromTumor = refName;
	    					posNormal = position;
	    					posTumor = position;

	    					// Parse normal, which should be first sample //
	    					int normalOffset = 3;
	    					int pileupDepthNormal = Integer.parseInt(lineContents[normalOffset]);
		    	        	//String normalBases = lineContents[normalOffset + 1];
		    	        	String normalQualities = lineContents[normalOffset + 2];

	    					// Parse tumor, which should be second sample //
	    					int tumorOffset = 6;
	    					int pileupDepthTumor = Integer.parseInt(lineContents[tumorOffset]);
		    	        	//String tumorBases = lineContents[tumorOffset + 1];
		    	        	String tumorQualities = lineContents[tumorOffset + 2];


		    	        	// If either sample met the minimum coverage and both had at least one read //

//		    	        	if((pileupDepthNormal >= minCoverage || pileupDepthTumor >= minCoverage) && normalQualities.length() > 0)// && tumorQualities.length() > 0)

		    	        	// We want the normal sample to meet the minimum coverage because that's the comparator //
		    	        	if(pileupDepthNormal >= minCoverage && normalQualities.length() > 0)// && tumorQualities.length() > 0)
	    					{
	    						comparedPositions++;
	    						// Get the depth of bases above minimum quality //

	    	    				int normalDepth = VarScan.qualityDepth(normalQualities, minBaseQual);
	    	    				int tumorDepth = 0;
	    	    				if(tumorQualities.length() > 0)
	    	    					tumorDepth = VarScan.qualityDepth(tumorQualities, minBaseQual);

	    	    				// Determine if we have a copy changepoint //
	    	    				// If this base is not contiguous with the copyRegion
	    	    				// If the normal or tumor depth changes //

	    	    				int diffNormal = Math.abs(copyDepthNormal - normalDepth);
	    	    				int diffTumor = Math.abs(copyDepthTumor - tumorDepth);
	    	    				int posDiff = posTumor - copyStop;

	    	    				// DETERMINE IF WE CONTINUE THIS REGION OR PROCESS IT AND START A NEW ONE //

	    	    				boolean continueFlag = false;

	    	    				// If chromosomes differ or contiguity broken, process the region //

	    	    				if(posDiff > 2 || !(copyChrom.equals(chromTumor)))
	    	    				{
	    	    					continueFlag = false;
	    	    				}
	    	    				else
	    	    				{
	    	    					if(copyPositions >= maxSegmentSize)
	    	    					{
	    	    						continueFlag = false;
	    	    					}
	    	    					else if(diffNormal <= 2 && diffTumor <= 2)
	    	    					{
	    	    						continueFlag = true;
	    	    					}
	    	    					else
	    	    					{
	    	    						// Do a Fisher's exact test on the copy number changes. ##

	        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

	        	    					// If depth change not significant, continue with region //
	        	    					if(changePvalue >= pValueThreshold)
	        	    					{
	        	    						continueFlag = true;
	        	    					}
	        	    					else
	        	    					{
	        	    						continueFlag = false;
	        	    					}

	    	    					}
	    	    				}


	    	    				// If continuing, extend this region and don't process yet //

	    	    				if(continueFlag)
	    	    				{
	    	    					copySumNormal += normalDepth;
	    	    					copySumTumor += tumorDepth;
	    	    					copyPositions++;
	    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
	    	    						copyPositionsGC++;
	    	    					copyStop = posTumor;
	    	    				}

	    	    				// Otherwise, process this region (if it qualifies) and start a new one //

	    	    				else
	    	    				{
	    	    					if(copyPositions >= minSegmentSize)
	    	    					{
	    	    						rawCopySegments++;
	    	    						String regionResults = processCopyRegion(copyChrom, copyStart, copyStop, copyPositions, copyPositionsGC, copySumNormal, copySumTumor, minCoverage, dataRatio);

	    	    						if(regionResults.length() > 0)
	    	    						{
	    	    							outCopySegments.println(regionResults);
	    	    							goodCopySegments++;
	    	    						}
	    	    					}

	    	    					// Start a new copyNumber region //
	    	    					copyChrom = chromTumor;
	    	    					copyStart = posTumor;
	    	    					copyStop = posTumor;
	    	    					copyDepthNormal = normalDepth;
	    	    					copyDepthTumor = tumorDepth;
	    	    					copySumNormal = normalDepth;
	    	    					copySumTumor = tumorDepth;
	    	    					copyPositions = 1;
	    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
	    	    						copyPositionsGC = 1;
	    	    					else
	    	    						copyPositionsGC = 0;
	    	    				}


	    					}
	    					else
	    					{
	    						// If minimum coverage was not met, print region //
		    					// If we had a copyNumber region that met minimum coverage, report it //
		    					if(copyPositions >= minSegmentSize)
		    					{
		    						rawCopySegments++;
		    						String regionResults = processCopyRegion(copyChrom, copyStart, copyStop, copyPositions, copyPositionsGC, copySumNormal, copySumTumor, minCoverage, dataRatio);

		    						if(regionResults.length() > 0)
		    						{
		    							outCopySegments.println(regionResults);
		    							goodCopySegments++;
		    						}
		    					}

		    					// Reset the copyNumber region //
		    					copyChrom = "";
		    					copyStart = 0;
		    					copyStop = 0;
		    					copyDepthNormal = 0;
		    					copyDepthTumor = 0;
		    					copySumNormal = 0;
		    					copySumTumor = 0;
		    					copyPositions = 0;
		    					copyPositionsGC = 0;
	    					}

	    				}
	    				else
	    				{
	    					System.err.println("Error: Invalid format or not enough samples in mpileup: " + line + "\n");
	    					return;
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }


	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834445
net/sf/varscan/Copynumber.java 244 345
net/sf/varscan/Copynumber.java 769 868
----------------------------------------
	    					{
	    						comparedPositions++;
	    						// Get the depth of bases above minimum quality //

	    	    				int normalDepth = VarScan.qualityDepth(normalQualities, minBaseQual);
	    	    				int tumorDepth = 0;
	    	    				if(tumorQualities.length() > 0)
	    	    					tumorDepth = VarScan.qualityDepth(tumorQualities, minBaseQual);

	    	    				// Determine if we have a copy changepoint //
	    	    				// If this base is not contiguous with the copyRegion
	    	    				// If the normal or tumor depth changes //

	    	    				int diffNormal = Math.abs(copyDepthNormal - normalDepth);
	    	    				int diffTumor = Math.abs(copyDepthTumor - tumorDepth);
	    	    				int posDiff = posTumor - copyStop;

	    	    				// DETERMINE IF WE CONTINUE THIS REGION OR PROCESS IT AND START A NEW ONE //

	    	    				boolean continueFlag = false;

	    	    				// If chromosomes differ or contiguity broken, process the region //

	    	    				if(posDiff > 2 || !(copyChrom.equals(chromTumor)))
	    	    				{
	    	    					continueFlag = false;
	    	    				}
	    	    				else
	    	    				{
	    	    					if(copyPositions >= maxSegmentSize)
	    	    					{
	    	    						continueFlag = false;
	    	    					}
	    	    					else if(diffNormal <= 2 && diffTumor <= 2)
	    	    					{
	    	    						continueFlag = true;
	    	    					}
	    	    					else
	    	    					{
	    	    						// Do a Fisher's exact test on the copy number changes. ##

	        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

	        	    					// If depth change not significant, continue with region //
	        	    					if(changePvalue >= pValueThreshold)
	        	    					{
	        	    						continueFlag = true;
	        	    					}
	        	    					else
	        	    					{
	        	    						continueFlag = false;
	        	    					}

	    	    					}
	    	    				}


	    	    				// If continuing, extend this region and don't process yet //

	    	    				if(continueFlag)
	    	    				{
	    	    					copySumNormal += normalDepth;
	    	    					copySumTumor += tumorDepth;
	    	    					copyPositions++;
	    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
	    	    						copyPositionsGC++;
	    	    					copyStop = posTumor;
	    	    				}

	    	    				// Otherwise, process this region (if it qualifies) and start a new one //

	    	    				else
	    	    				{
	    	    					if(copyPositions >= minSegmentSize)
	    	    					{
	    	    						rawCopySegments++;
	    	    						String regionResults = processCopyRegion(copyChrom, copyStart, copyStop, copyPositions, copyPositionsGC, copySumNormal, copySumTumor, minCoverage, dataRatio);

	    	    						if(regionResults.length() > 0)
	    	    						{
	    	    							outCopySegments.println(regionResults);
	    	    							goodCopySegments++;
	    	    						}
	    	    					}

	    	    					// Start a new copyNumber region //
	    	    					copyChrom = chromTumor;
	    	    					copyStart = posTumor;
	    	    					copyStop = posTumor;
	    	    					copyDepthNormal = normalDepth;
	    	    					copyDepthTumor = tumorDepth;
	    	    					copySumNormal = normalDepth;
	    	    					copySumTumor = tumorDepth;
	    	    					copyPositions = 1;
	    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
	    	    						copyPositionsGC = 1;
	    	    					else
	    	    						copyPositionsGC = 0;
	    	    				}


	    					}

----------------------------------------
    					{
    						comparedPositions++;
//    						 Get the depth of bases above minimum quality //

    	    				int normalDepth = VarScan.qualityDepth(normalQualities, minBaseQual);
    	    				int tumorDepth = VarScan.qualityDepth(tumorQualities, minBaseQual);

    	    				// Determine if we have a copy changepoint //
    	    				// If this base is not contiguous with the copyRegion
    	    				// If the normal or tumor depth changes //

    	    				int diffNormal = Math.abs(copyDepthNormal - normalDepth);
    	    				int diffTumor = Math.abs(copyDepthTumor - tumorDepth);
    	    				int posDiff = posTumor - copyStop;

    	    				// DETERMINE IF WE CONTINUE THIS REGION OR PROCESS IT AND START A NEW ONE //

    	    				boolean continueFlag = false;

    	    				// If chromosomes differ or contiguity broken, process the region //

    	    				if(posDiff > 2 || !(copyChrom.equals(chromTumor)))
    	    				{
    	    					continueFlag = false;
    	    				}
    	    				else
    	    				{
    	    					if(copyPositions >= maxSegmentSize)
    	    					{
    	    						continueFlag = false;
    	    					}
    	    					else if(diffNormal <= 2 && diffTumor <= 2)
    	    					{
    	    						continueFlag = true;
    	    					}
    	    					else
    	    					{
    	    						// Do a Fisher's exact test on the copy number changes. ##

        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

        	    					// If depth change not significant, continue with region //
        	    					if(changePvalue >= pValueThreshold)
        	    					{
        	    						continueFlag = true;
        	    					}
        	    					else
        	    					{
        	    						continueFlag = false;
        	    					}

    	    					}
    	    				}


    	    				// If continuing, extend this region and don't process yet //

    	    				if(continueFlag)
    	    				{
    	    					copySumNormal += normalDepth;
    	    					copySumTumor += tumorDepth;
    	    					copyPositions++;
    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
    	    						copyPositionsGC++;
    	    					copyStop = posTumor;
    	    				}

    	    				// Otherwise, process this region (if it qualifies) and start a new one //

    	    				else
    	    				{
    	    					if(copyPositions >= minSegmentSize)
    	    					{
    	    						rawCopySegments++;
    	    						String regionResults = processCopyRegion(copyChrom, copyStart, copyStop, copyPositions, copyPositionsGC, copySumNormal, copySumTumor, minCoverage, dataRatio);

    	    						if(regionResults.length() > 0)
    	    						{
    	    							outCopySegments.println(regionResults);
    	    							goodCopySegments++;
    	    						}
    	    					}

    	    					// Start a new copyNumber region //
    	    					copyChrom = chromTumor;
    	    					copyStart = posTumor;
    	    					copyStop = posTumor;
    	    					copyDepthNormal = normalDepth;
    	    					copyDepthTumor = tumorDepth;
    	    					copySumNormal = normalDepth;
    	    					copySumTumor = tumorDepth;
    	    					copyPositions = 1;
    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
    	    						copyPositionsGC = 1;
    	    					else
    	    						copyPositionsGC = 0;
    	    				}


    					}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834446
net/sf/varscan/Copynumber.java 272 298
net/sf/varscan/Copynumber.java 795 821
----------------------------------------
	    	    				{
	    	    					if(copyPositions >= maxSegmentSize)
	    	    					{
	    	    						continueFlag = false;
	    	    					}
	    	    					else if(diffNormal <= 2 && diffTumor <= 2)
	    	    					{
	    	    						continueFlag = true;
	    	    					}
	    	    					else
	    	    					{
	    	    						// Do a Fisher's exact test on the copy number changes. ##

	        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

	        	    					// If depth change not significant, continue with region //
	        	    					if(changePvalue >= pValueThreshold)
	        	    					{
	        	    						continueFlag = true;
	        	    					}
	        	    					else
	        	    					{
	        	    						continueFlag = false;
	        	    					}

	    	    					}
	    	    				}

----------------------------------------
    	    				{
    	    					if(copyPositions >= maxSegmentSize)
    	    					{
    	    						continueFlag = false;
    	    					}
    	    					else if(diffNormal <= 2 && diffTumor <= 2)
    	    					{
    	    						continueFlag = true;
    	    					}
    	    					else
    	    					{
    	    						// Do a Fisher's exact test on the copy number changes. ##

        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

        	    					// If depth change not significant, continue with region //
        	    					if(changePvalue >= pValueThreshold)
        	    					{
        	    						continueFlag = true;
        	    					}
        	    					else
        	    					{
        	    						continueFlag = false;
        	    					}

    	    					}
    	    				}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834462
net/sf/varscan/Somatic.java 496 508
net/sf/varscan/Copynumber.java 805 820
----------------------------------------
			    					{
			    						// Somatic //
			    						ssCode = 2;
			    						calledSomatic++;
			    						if(somaticP == 0)
			    						{
			    							somScore = 255;
			    						}
			    						else
			    						{
			    							somScore = 0 - (10 * java.lang.Math.log10(somaticP));
			    						}
			    					}

----------------------------------------
    	    					{
    	    						// Do a Fisher's exact test on the copy number changes. ##

        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

        	    					// If depth change not significant, continue with region //
        	    					if(changePvalue >= pValueThreshold)
        	    					{
        	    						continueFlag = true;
        	    					}
        	    					else
        	    					{
        	    						continueFlag = false;
        	    					}

    	    					}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834461
net/sf/varscan/Somatic.java 1224 1236
net/sf/varscan/Copynumber.java 805 820
----------------------------------------
		    					{
		    						// Somatic //
		    						ssCode = 2;
		    						calledSomatic++;
		    						if(somaticP == 0)
		    						{
		    							somScore = 255;
		    						}
		    						else
		    						{
		    							somScore = 0 - (10 * java.lang.Math.log10(somaticP));
		    						}
		    					}

----------------------------------------
    	    					{
    	    						// Do a Fisher's exact test on the copy number changes. ##

        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

        	    					// If depth change not significant, continue with region //
        	    					if(changePvalue >= pValueThreshold)
        	    					{
        	    						continueFlag = true;
        	    					}
        	    					else
        	    					{
        	    						continueFlag = false;
        	    					}

    	    					}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834463
net/sf/varscan/Somatic.java 510 522
net/sf/varscan/Copynumber.java 805 820
----------------------------------------
			    					{
			    						// LOH //
			    						ssCode = 3;
			    						calledLOH++;
			    						if(somaticP == 0)
			    						{
			    							somScore = 255;
			    						}
			    						else
			    						{
			    							somScore = 0 - (10 * java.lang.Math.log10(somaticP));
			    						}
			    					}

----------------------------------------
    	    					{
    	    						// Do a Fisher's exact test on the copy number changes. ##

        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

        	    					// If depth change not significant, continue with region //
        	    					if(changePvalue >= pValueThreshold)
        	    					{
        	    						continueFlag = true;
        	    					}
        	    					else
        	    					{
        	    						continueFlag = false;
        	    					}

    	    					}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834448
net/sf/varscan/Somatic.java 482 494
net/sf/varscan/Copynumber.java 805 820
----------------------------------------
			    					{
			    						// Germline //
			    						ssCode = 1;
			    						calledGermline++;
			    						if(somaticP == 0)
			    						{
			    							somScore = 0;
			    						}
			    						else
			    						{
			    							somScore = 0 - (10 * java.lang.Math.log10(somaticP));
			    						}
			    					}

----------------------------------------
    	    					{
    	    						// Do a Fisher's exact test on the copy number changes. ##

        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

        	    					// If depth change not significant, continue with region //
        	    					if(changePvalue >= pValueThreshold)
        	    					{
        	    						continueFlag = true;
        	    					}
        	    					else
        	    					{
        	    						continueFlag = false;
        	    					}

    	    					}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834447
net/sf/varscan/Somatic.java 1238 1250
net/sf/varscan/Copynumber.java 805 820
----------------------------------------
		    					{
		    						// LOH //
		    						ssCode = 3;
		    						calledLOH++;
		    						if(somaticP == 0)
		    						{
		    							somScore = 255;
		    						}
		    						else
		    						{
		    							somScore = 0 - (10 * java.lang.Math.log10(somaticP));
		    						}
		    					}

----------------------------------------
    	    					{
    	    						// Do a Fisher's exact test on the copy number changes. ##

        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

        	    					// If depth change not significant, continue with region //
        	    					if(changePvalue >= pValueThreshold)
        	    					{
        	    						continueFlag = true;
        	    					}
        	    					else
        	    					{
        	    						continueFlag = false;
        	    					}

    	    					}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834449
net/sf/varscan/Somatic.java 1210 1222
net/sf/varscan/Copynumber.java 805 820
----------------------------------------
		    					{
		    						// Germline //
		    						ssCode = 1;
		    						calledGermline++;
		    						if(somaticP == 0)
		    						{
		    							somScore = 0;
		    						}
		    						else
		    						{
		    							somScore = 0 - (10 * java.lang.Math.log10(somaticP));
		    						}
		    					}

----------------------------------------
    	    					{
    	    						// Do a Fisher's exact test on the copy number changes. ##

        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

        	    					// If depth change not significant, continue with region //
        	    					if(changePvalue >= pValueThreshold)
        	    					{
        	    						continueFlag = true;
        	    					}
        	    					else
        	    					{
        	    						continueFlag = false;
        	    					}

    	    					}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834762
net/sf/varscan/Somatic.java 510 522
net/sf/varscan/Copynumber.java 282 297
----------------------------------------
			    					{
			    						// LOH //
			    						ssCode = 3;
			    						calledLOH++;
			    						if(somaticP == 0)
			    						{
			    							somScore = 255;
			    						}
			    						else
			    						{
			    							somScore = 0 - (10 * java.lang.Math.log10(somaticP));
			    						}
			    					}

----------------------------------------
	    	    					{
	    	    						// Do a Fisher's exact test on the copy number changes. ##

	        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

	        	    					// If depth change not significant, continue with region //
	        	    					if(changePvalue >= pValueThreshold)
	        	    					{
	        	    						continueFlag = true;
	        	    					}
	        	    					else
	        	    					{
	        	    						continueFlag = false;
	        	    					}

	    	    					}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834760
net/sf/varscan/Somatic.java 1224 1236
net/sf/varscan/Copynumber.java 282 297
----------------------------------------
		    					{
		    						// Somatic //
		    						ssCode = 2;
		    						calledSomatic++;
		    						if(somaticP == 0)
		    						{
		    							somScore = 255;
		    						}
		    						else
		    						{
		    							somScore = 0 - (10 * java.lang.Math.log10(somaticP));
		    						}
		    					}

----------------------------------------
	    	    					{
	    	    						// Do a Fisher's exact test on the copy number changes. ##

	        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

	        	    					// If depth change not significant, continue with region //
	        	    					if(changePvalue >= pValueThreshold)
	        	    					{
	        	    						continueFlag = true;
	        	    					}
	        	    					else
	        	    					{
	        	    						continueFlag = false;
	        	    					}

	    	    					}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834757
net/sf/varscan/Somatic.java 1238 1250
net/sf/varscan/Copynumber.java 282 297
----------------------------------------
		    					{
		    						// LOH //
		    						ssCode = 3;
		    						calledLOH++;
		    						if(somaticP == 0)
		    						{
		    							somScore = 255;
		    						}
		    						else
		    						{
		    							somScore = 0 - (10 * java.lang.Math.log10(somaticP));
		    						}
		    					}

----------------------------------------
	    	    					{
	    	    						// Do a Fisher's exact test on the copy number changes. ##

	        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

	        	    					// If depth change not significant, continue with region //
	        	    					if(changePvalue >= pValueThreshold)
	        	    					{
	        	    						continueFlag = true;
	        	    					}
	        	    					else
	        	    					{
	        	    						continueFlag = false;
	        	    					}

	    	    					}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834759
net/sf/varscan/Somatic.java 1210 1222
net/sf/varscan/Copynumber.java 282 297
----------------------------------------
		    					{
		    						// Germline //
		    						ssCode = 1;
		    						calledGermline++;
		    						if(somaticP == 0)
		    						{
		    							somScore = 0;
		    						}
		    						else
		    						{
		    							somScore = 0 - (10 * java.lang.Math.log10(somaticP));
		    						}
		    					}

----------------------------------------
	    	    					{
	    	    						// Do a Fisher's exact test on the copy number changes. ##

	        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

	        	    					// If depth change not significant, continue with region //
	        	    					if(changePvalue >= pValueThreshold)
	        	    					{
	        	    						continueFlag = true;
	        	    					}
	        	    					else
	        	    					{
	        	    						continueFlag = false;
	        	    					}

	    	    					}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834761
net/sf/varscan/Somatic.java 496 508
net/sf/varscan/Copynumber.java 282 297
----------------------------------------
			    					{
			    						// Somatic //
			    						ssCode = 2;
			    						calledSomatic++;
			    						if(somaticP == 0)
			    						{
			    							somScore = 255;
			    						}
			    						else
			    						{
			    							somScore = 0 - (10 * java.lang.Math.log10(somaticP));
			    						}
			    					}

----------------------------------------
	    	    					{
	    	    						// Do a Fisher's exact test on the copy number changes. ##

	        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

	        	    					// If depth change not significant, continue with region //
	        	    					if(changePvalue >= pValueThreshold)
	        	    					{
	        	    						continueFlag = true;
	        	    					}
	        	    					else
	        	    					{
	        	    						continueFlag = false;
	        	    					}

	    	    					}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834460
net/sf/varscan/Copynumber.java 805 820
net/sf/varscan/Copynumber.java 282 297
----------------------------------------
    	    					{
    	    						// Do a Fisher's exact test on the copy number changes. ##

        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

        	    					// If depth change not significant, continue with region //
        	    					if(changePvalue >= pValueThreshold)
        	    					{
        	    						continueFlag = true;
        	    					}
        	    					else
        	    					{
        	    						continueFlag = false;
        	    					}

    	    					}

----------------------------------------
	    	    					{
	    	    						// Do a Fisher's exact test on the copy number changes. ##

	        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

	        	    					// If depth change not significant, continue with region //
	        	    					if(changePvalue >= pValueThreshold)
	        	    					{
	        	    						continueFlag = true;
	        	    					}
	        	    					else
	        	    					{
	        	    						continueFlag = false;
	        	    					}

	    	    					}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834758
net/sf/varscan/Somatic.java 482 494
net/sf/varscan/Copynumber.java 282 297
----------------------------------------
			    					{
			    						// Germline //
			    						ssCode = 1;
			    						calledGermline++;
			    						if(somaticP == 0)
			    						{
			    							somScore = 0;
			    						}
			    						else
			    						{
			    							somScore = 0 - (10 * java.lang.Math.log10(somaticP));
			    						}
			    					}

----------------------------------------
	    	    					{
	    	    						// Do a Fisher's exact test on the copy number changes. ##

	        	    					double changePvalue = VarScan.getSignificance(copyDepthNormal, copyDepthTumor, normalDepth, tumorDepth);

	        	    					// If depth change not significant, continue with region //
	        	    					if(changePvalue >= pValueThreshold)
	        	    					{
	        	    						continueFlag = true;
	        	    					}
	        	    					else
	        	    					{
	        	    						continueFlag = false;
	        	    					}

	    	    					}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834464
net/sf/varscan/Copynumber.java 304 311
net/sf/varscan/Copynumber.java 827 834
----------------------------------------
	    	    				{
	    	    					copySumNormal += normalDepth;
	    	    					copySumTumor += tumorDepth;
	    	    					copyPositions++;
	    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
	    	    						copyPositionsGC++;
	    	    					copyStop = posTumor;
	    	    				}

----------------------------------------
    	    				{
    	    					copySumNormal += normalDepth;
    	    					copySumTumor += tumorDepth;
    	    					copyPositions++;
    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
    	    						copyPositionsGC++;
    	    					copyStop = posTumor;
    	    				}

----------------------------------------
