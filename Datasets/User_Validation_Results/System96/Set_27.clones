$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805757
net/sf/varscan/CallPileup.java 140 157
net/sf/varscan/Somatic.java 254 271
----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805769
net/sf/varscan/FilterVariants.java 160 177
net/sf/varscan/Somatic.java 254 271
----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805766
net/sf/varscan/FilterSomatic.java 164 181
net/sf/varscan/Somatic.java 254 271
----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805771
net/sf/varscan/ProcessSomatic.java 78 95
net/sf/varscan/Somatic.java 254 271
----------------------------------------
	    	while(!infile.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805762
net/sf/varscan/Copynumber.java 138 155
net/sf/varscan/Somatic.java 254 271
----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805751
net/sf/varscan/CallMpileup.java 232 249
net/sf/varscan/Somatic.java 254 271
----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805772
net/sf/varscan/ProcessSomatic.java 78 95
net/sf/varscan/Trio.java 252 269
----------------------------------------
	    	while(!infile.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805770
net/sf/varscan/FilterVariants.java 160 177
net/sf/varscan/Trio.java 252 269
----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805767
net/sf/varscan/FilterSomatic.java 164 181
net/sf/varscan/Trio.java 252 269
----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805752
net/sf/varscan/CallMpileup.java 232 249
net/sf/varscan/Trio.java 252 269
----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805758
net/sf/varscan/CallPileup.java 140 157
net/sf/varscan/Trio.java 252 269
----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805763
net/sf/varscan/Copynumber.java 138 155
net/sf/varscan/Trio.java 252 269
----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805773
net/sf/varscan/Somatic.java 254 271
net/sf/varscan/Trio.java 252 269
----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805774
net/sf/varscan/CopyCaller.java 176 197
net/sf/varscan/ProcessSomatic.java 69 91
----------------------------------------
	    	if(in == null)
	    	{
	    		System.out.println(usage);
				return;
	    	}

	    	// If input file not ready, give it a few seconds //
	    	int numNaps = 0;

	    	if(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;
			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
	    		}
		    	catch(Exception e)
		    	{

----------------------------------------
	    	if(infile == null)
	    	{
	    		System.out.println(usage);
				return;
	    	}

	    	// If input file not ready, give it a few seconds //
	    	int numNaps = 0;

	    	while(!infile.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805776
net/sf/varscan/FilterSomatic.java 84 100
net/sf/varscan/CallMpileup.java 91 107
----------------------------------------
			if(params.containsKey("min-coverage"))
				 minCoverage = Integer.parseInt(params.get("min-coverage"));

			if(params.containsKey("min-reads2"))
				 minReads2 = Integer.parseInt(params.get("min-reads2"));

			if(params.containsKey("min-strands2"))
				 minStrands2 = Integer.parseInt(params.get("min-strands2"));

			if(params.containsKey("min-var-freq"))
				 minVarFreq = Double.parseDouble(params.get("min-var-freq"));

			if(params.containsKey("min-avg-qual"))
				 minAvgQual = Integer.parseInt(params.get("min-avg-qual"));

			if(params.containsKey("p-value"))
				 pValueThreshold = Double.parseDouble(params.get("p-value"));

----------------------------------------
			if(params.containsKey("min-coverage"))
				 minCoverage = Integer.parseInt(params.get("min-coverage"));

			if(params.containsKey("min-reads2"))
				 minReads2 = Integer.parseInt(params.get("min-reads2"));

			if(params.containsKey("min-var-freq"))
				 minVarFreq = Double.parseDouble(params.get("min-var-freq"));

			if(params.containsKey("min-freq-for-hom"))
				 minFreqForHom = Double.parseDouble(params.get("min-freq-for-hom"));

			if(params.containsKey("min-avg-qual"))
				 minAvgQual = Integer.parseInt(params.get("min-avg-qual"));

			if(params.containsKey("p-value"))
				 pValueThreshold = Double.parseDouble(params.get("p-value"));

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805775
net/sf/varscan/CallMpileup.java 91 107
net/sf/varscan/CallPileup.java 61 77
----------------------------------------
			if(params.containsKey("min-coverage"))
				 minCoverage = Integer.parseInt(params.get("min-coverage"));

			if(params.containsKey("min-reads2"))
				 minReads2 = Integer.parseInt(params.get("min-reads2"));

			if(params.containsKey("min-var-freq"))
				 minVarFreq = Double.parseDouble(params.get("min-var-freq"));

			if(params.containsKey("min-freq-for-hom"))
				 minFreqForHom = Double.parseDouble(params.get("min-freq-for-hom"));

			if(params.containsKey("min-avg-qual"))
				 minAvgQual = Integer.parseInt(params.get("min-avg-qual"));

			if(params.containsKey("p-value"))
				 pValueThreshold = Double.parseDouble(params.get("p-value"));

----------------------------------------
			if(params.containsKey("min-coverage"))
				 minCoverage = Integer.parseInt(params.get("min-coverage"));

			if(params.containsKey("min-reads2"))
				 minReads2 = Integer.parseInt(params.get("min-reads2"));

			if(params.containsKey("min-var-freq"))
				 minVarFreq = Double.parseDouble(params.get("min-var-freq"));

			if(params.containsKey("min-freq-for-hom"))
				 minFreqForHom = Double.parseDouble(params.get("min-freq-for-hom"));

			if(params.containsKey("min-avg-qual"))
				 minAvgQual = Integer.parseInt(params.get("min-avg-qual"));

			if(params.containsKey("p-value"))
				 pValueThreshold = Double.parseDouble(params.get("p-value"));

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805777
net/sf/varscan/FilterSomatic.java 84 100
net/sf/varscan/CallPileup.java 61 77
----------------------------------------
			if(params.containsKey("min-coverage"))
				 minCoverage = Integer.parseInt(params.get("min-coverage"));

			if(params.containsKey("min-reads2"))
				 minReads2 = Integer.parseInt(params.get("min-reads2"));

			if(params.containsKey("min-strands2"))
				 minStrands2 = Integer.parseInt(params.get("min-strands2"));

			if(params.containsKey("min-var-freq"))
				 minVarFreq = Double.parseDouble(params.get("min-var-freq"));

			if(params.containsKey("min-avg-qual"))
				 minAvgQual = Integer.parseInt(params.get("min-avg-qual"));

			if(params.containsKey("p-value"))
				 pValueThreshold = Double.parseDouble(params.get("p-value"));

----------------------------------------
			if(params.containsKey("min-coverage"))
				 minCoverage = Integer.parseInt(params.get("min-coverage"));

			if(params.containsKey("min-reads2"))
				 minReads2 = Integer.parseInt(params.get("min-reads2"));

			if(params.containsKey("min-var-freq"))
				 minVarFreq = Double.parseDouble(params.get("min-var-freq"));

			if(params.containsKey("min-freq-for-hom"))
				 minFreqForHom = Double.parseDouble(params.get("min-freq-for-hom"));

			if(params.containsKey("min-avg-qual"))
				 minAvgQual = Integer.parseInt(params.get("min-avg-qual"));

			if(params.containsKey("p-value"))
				 pValueThreshold = Double.parseDouble(params.get("p-value"));

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805778
net/sf/varscan/Trio.java 553 580
net/sf/varscan/Trio.java 649 676
----------------------------------------
		    	        				int reads2minus = Integer.parseInt(fatherContents[14]);

		    	        				double logP = 0;
		    	        				try {
			    	        				logP = 0 - (10 * java.lang.Math.log10(pValue));
			    	        				if(logP > 255)
			    	        					logP = 255;
		    	        				}
		    	        				catch(Exception e)
		    	        				{
		    	        					// Stick with default logP value
		    	        				}

		    	        				// Father is wildtype //
		    	        				if(consBase.equals(refBase))
		    	        				{
		    	        					// A reference call - recalculate p-value against a possible het //
		    	        					int expReads1 = (reads1 + reads2) / 2;
		    	        					int expReads2 = (reads1 + reads2) - expReads1;
		    	        					double newPvalue = VarScan.getSignificance(reads1, reads2, expReads1, expReads2);
		    	        					double newLogP = 0;
			    	        				try {
				    	        				newLogP = 0 - (10 * java.lang.Math.log10(newPvalue));
			    	        				}
			    	        				catch(Exception e)
			    	        				{
			    	        					// Stick with default logP value
			    	        				}

----------------------------------------
		    	        				int reads2minus = Integer.parseInt(motherContents[14]);

		    	        				double logP = 0;
		    	        				try {
			    	        				logP = 0 - (10 * java.lang.Math.log10(pValue));
			    	        				if(logP > 255)
			    	        					logP = 255;
		    	        				}
		    	        				catch(Exception e)
		    	        				{
		    	        					// Stick with default logP value
		    	        				}

		    	        				// mother is wildtype //
		    	        				if(consBase.equals(refBase))
		    	        				{
		    	        					// A reference call - recalculate p-value against a possible het //
		    	        					int expReads1 = (reads1 + reads2) / 2;
		    	        					int expReads2 = (reads1 + reads2) - expReads1;
		    	        					double newPvalue = VarScan.getSignificance(reads1, reads2, expReads1, expReads2);
		    	        					double newLogP = 0;
			    	        				try {
				    	        				newLogP = 0 - (10 * java.lang.Math.log10(newPvalue));
			    	        				}
			    	        				catch(Exception e)
			    	        				{
			    	        					// Stick with default logP value
			    	        				}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805780
net/sf/varscan/Trio.java 649 676
net/sf/varscan/Trio.java 745 772
----------------------------------------
		    	        				int reads2minus = Integer.parseInt(motherContents[14]);

		    	        				double logP = 0;
		    	        				try {
			    	        				logP = 0 - (10 * java.lang.Math.log10(pValue));
			    	        				if(logP > 255)
			    	        					logP = 255;
		    	        				}
		    	        				catch(Exception e)
		    	        				{
		    	        					// Stick with default logP value
		    	        				}

		    	        				// mother is wildtype //
		    	        				if(consBase.equals(refBase))
		    	        				{
		    	        					// A reference call - recalculate p-value against a possible het //
		    	        					int expReads1 = (reads1 + reads2) / 2;
		    	        					int expReads2 = (reads1 + reads2) - expReads1;
		    	        					double newPvalue = VarScan.getSignificance(reads1, reads2, expReads1, expReads2);
		    	        					double newLogP = 0;
			    	        				try {
				    	        				newLogP = 0 - (10 * java.lang.Math.log10(newPvalue));
			    	        				}
			    	        				catch(Exception e)
			    	        				{
			    	        					// Stick with default logP value
			    	        				}

----------------------------------------
		    	        				int reads2minus = Integer.parseInt(childContents[14]);

		    	        				double logP = 0;
		    	        				try {
			    	        				logP = 0 - (10 * java.lang.Math.log10(pValue));
			    	        				if(logP > 255)
			    	        					logP = 255;
		    	        				}
		    	        				catch(Exception e)
		    	        				{
		    	        					// Stick with default logP value
		    	        				}

		    	        				// child is wildtype //
		    	        				if(consBase.equals(refBase))
		    	        				{
		    	        					// A reference call - recalculate p-value against a possible het //
		    	        					int expReads1 = (reads1 + reads2) / 2;
		    	        					int expReads2 = (reads1 + reads2) - expReads1;
		    	        					double newPvalue = VarScan.getSignificance(reads1, reads2, expReads1, expReads2);
		    	        					double newLogP = 0;
			    	        				try {
				    	        				newLogP = 0 - (10 * java.lang.Math.log10(newPvalue));
			    	        				}
			    	        				catch(Exception e)
			    	        				{
			    	        					// Stick with default logP value
			    	        				}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805779
net/sf/varscan/Trio.java 553 580
net/sf/varscan/Trio.java 745 772
----------------------------------------
		    	        				int reads2minus = Integer.parseInt(fatherContents[14]);

		    	        				double logP = 0;
		    	        				try {
			    	        				logP = 0 - (10 * java.lang.Math.log10(pValue));
			    	        				if(logP > 255)
			    	        					logP = 255;
		    	        				}
		    	        				catch(Exception e)
		    	        				{
		    	        					// Stick with default logP value
		    	        				}

		    	        				// Father is wildtype //
		    	        				if(consBase.equals(refBase))
		    	        				{
		    	        					// A reference call - recalculate p-value against a possible het //
		    	        					int expReads1 = (reads1 + reads2) / 2;
		    	        					int expReads2 = (reads1 + reads2) - expReads1;
		    	        					double newPvalue = VarScan.getSignificance(reads1, reads2, expReads1, expReads2);
		    	        					double newLogP = 0;
			    	        				try {
				    	        				newLogP = 0 - (10 * java.lang.Math.log10(newPvalue));
			    	        				}
			    	        				catch(Exception e)
			    	        				{
			    	        					// Stick with default logP value
			    	        				}

----------------------------------------
		    	        				int reads2minus = Integer.parseInt(childContents[14]);

		    	        				double logP = 0;
		    	        				try {
			    	        				logP = 0 - (10 * java.lang.Math.log10(pValue));
			    	        				if(logP > 255)
			    	        					logP = 255;
		    	        				}
		    	        				catch(Exception e)
		    	        				{
		    	        					// Stick with default logP value
		    	        				}

		    	        				// child is wildtype //
		    	        				if(consBase.equals(refBase))
		    	        				{
		    	        					// A reference call - recalculate p-value against a possible het //
		    	        					int expReads1 = (reads1 + reads2) / 2;
		    	        					int expReads2 = (reads1 + reads2) - expReads1;
		    	        					double newPvalue = VarScan.getSignificance(reads1, reads2, expReads1, expReads2);
		    	        					double newLogP = 0;
			    	        				try {
				    	        				newLogP = 0 - (10 * java.lang.Math.log10(newPvalue));
			    	        				}
			    	        				catch(Exception e)
			    	        				{
			    	        					// Stick with default logP value
			    	        				}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805781
net/sf/varscan/Trio.java 620 625
net/sf/varscan/Trio.java 716 721
----------------------------------------
		    	        						fatherVCF += ":" + reads1 + ":" + reads2 + ":" + varFreq + ":" + pvalueFormat.format(pValue);
		    	        						fatherVCF += ":" + qual1 + ":" + qual2;
		    	        						fatherVCF += ":" + reads1plus + ":" + reads1minus + ":" + reads2plus + ":" + reads2minus;
			    	        				}

		    	        					if(fatherAllele.length() > 1)

----------------------------------------
		    	        						motherVCF += ":" + reads1 + ":" + reads2 + ":" + varFreq + ":" + pvalueFormat.format(pValue);
		    	        						motherVCF += ":" + qual1 + ":" + qual2;
		    	        						motherVCF += ":" + reads1plus + ":" + reads1minus + ":" + reads2plus + ":" + reads2minus;
			    	        				}

		    	        					if(motherAllele.length() > 1)

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805782
net/sf/varscan/Trio.java 620 625
net/sf/varscan/Trio.java 812 817
----------------------------------------
		    	        						fatherVCF += ":" + reads1 + ":" + reads2 + ":" + varFreq + ":" + pvalueFormat.format(pValue);
		    	        						fatherVCF += ":" + qual1 + ":" + qual2;
		    	        						fatherVCF += ":" + reads1plus + ":" + reads1minus + ":" + reads2plus + ":" + reads2minus;
			    	        				}

		    	        					if(fatherAllele.length() > 1)

----------------------------------------
		    	        						childVCF += ":" + reads1 + ":" + reads2 + ":" + varFreq + ":" + pvalueFormat.format(pValue);
		    	        						childVCF += ":" + qual1 + ":" + qual2;
		    	        						childVCF += ":" + reads1plus + ":" + reads1minus + ":" + reads2plus + ":" + reads2minus;
			    	        				}

		    	        					if(childAllele.length() > 1)

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805783
net/sf/varscan/Trio.java 716 721
net/sf/varscan/Trio.java 812 817
----------------------------------------
		    	        						motherVCF += ":" + reads1 + ":" + reads2 + ":" + varFreq + ":" + pvalueFormat.format(pValue);
		    	        						motherVCF += ":" + qual1 + ":" + qual2;
		    	        						motherVCF += ":" + reads1plus + ":" + reads1minus + ":" + reads2plus + ":" + reads2minus;
			    	        				}

		    	        					if(motherAllele.length() > 1)

----------------------------------------
		    	        						childVCF += ":" + reads1 + ":" + reads2 + ":" + varFreq + ":" + pvalueFormat.format(pValue);
		    	        						childVCF += ":" + qual1 + ":" + qual2;
		    	        						childVCF += ":" + reads1plus + ":" + reads1minus + ":" + reads2plus + ":" + reads2minus;
			    	        				}

		    	        					if(childAllele.length() > 1)

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805784
net/sf/varscan/CopyCaller.java 277 287
net/sf/varscan/CopyCaller.java 496 506
----------------------------------------
	    					}
	    				}
	    				else
	    				{
	    					System.err.println("Error: Invalid format for pileup at line " + stats.get("numBases") + "\n" + line + "\n");
	    					return;
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());

----------------------------------------
	    					}
	    				}
	    				else
	    				{
	    					System.err.println("Error: Invalid format for pileup at line " + stats.get("numBases") + "\n" + line + "\n");
	    					return;
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getMessage() + "\n" + e.getLocalizedMessage());

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805786
net/sf/varscan/CopyCaller.java 496 506
net/sf/varscan/ReadCounts.java 293 304
----------------------------------------
	    					}
	    				}
	    				else
	    				{
	    					System.err.println("Error: Invalid format for pileup at line " + stats.get("numBases") + "\n" + line + "\n");
	    					return;
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getMessage() + "\n" + e.getLocalizedMessage());

----------------------------------------
		    	        	}

	    				}
	    				else
	    				{
	    					System.err.println("Error: Invalid format for pileup at line " + stats.get("numBases") + "\n" + line + "\n");
	    					return;
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805785
net/sf/varscan/CopyCaller.java 277 287
net/sf/varscan/ReadCounts.java 293 304
----------------------------------------
	    					}
	    				}
	    				else
	    				{
	    					System.err.println("Error: Invalid format for pileup at line " + stats.get("numBases") + "\n" + line + "\n");
	    					return;
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());

----------------------------------------
		    	        	}

	    				}
	    				else
	    				{
	    					System.err.println("Error: Invalid format for pileup at line " + stats.get("numBases") + "\n" + line + "\n");
	    					return;
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805787
net/sf/varscan/LimitVariants.java 81 99
net/sf/varscan/ProcessSomatic.java 47 65
----------------------------------------
		}
		catch(Exception e)
		{
	    	System.err.println("Input Parameter Threw Exception: " + e.getLocalizedMessage());
	    	e.printStackTrace(System.err);
	    	return;
		}

		// Print usage if -h or --help invoked //
		if(params.containsKey("help") || params.containsKey("h"))
		{
			System.err.println(usage);
			return;
		}

		try
		{
	 	 	// Obtain input file //
			BufferedReader infile = VarScan.getInfile(args);

----------------------------------------
		}
		catch(Exception e)
		{
	    	System.err.println("Input Parameter Threw Exception: " + e.getLocalizedMessage());
	    	e.printStackTrace(System.err);
	    	System.exit(1);
		}

		// Print usage if -h or --help invoked //
		if(params.containsKey("help") || params.containsKey("h"))
		{
			System.err.println(usage);
			return;
		}

		try
		{
			//			 Obtain input file //
			BufferedReader infile = VarScan.getInfile(args);

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805788
net/sf/varscan/LimitVariants.java 240 309
net/sf/varscan/ProcessSomatic.java 361 430
----------------------------------------
	    		else if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}
		catch(Exception e)
		{
			System.err.println("ERROR: File Parsing Exception: " + e.getLocalizedMessage());
			e.printStackTrace(System.err);
		}


		return(positionsByChrom);
	}

----------------------------------------
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}
		catch(Exception e)
		{
			System.err.println("ERROR: File Parsing Exception: " + e.getLocalizedMessage());
			e.printStackTrace(System.err);
		}


		return(positionsByChrom);
	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805790
net/sf/varscan/Copynumber.java 379 394
net/sf/varscan/CallMpileup.java 917 932
----------------------------------------
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }


	    		}

----------------------------------------
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }


	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805789
net/sf/varscan/CallMpileup.java 917 932
net/sf/varscan/CallPileup.java 291 306
----------------------------------------
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }


	    		}

----------------------------------------
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }


	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805793
net/sf/varscan/Copynumber.java 379 394
net/sf/varscan/CallPileup.java 291 306
----------------------------------------
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }


	    		}

----------------------------------------
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }


	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805796
net/sf/varscan/Copynumber.java 379 394
net/sf/varscan/Coverage.java 224 239
----------------------------------------
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }


	    		}

----------------------------------------
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }


	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805794
net/sf/varscan/CallPileup.java 291 306
net/sf/varscan/Coverage.java 224 239
----------------------------------------
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }


	    		}

----------------------------------------
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }


	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805791
net/sf/varscan/CallMpileup.java 917 932
net/sf/varscan/Coverage.java 224 239
----------------------------------------
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }


	    		}

----------------------------------------
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }


	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805797
net/sf/varscan/Copynumber.java 379 394
net/sf/varscan/Somatic.java 665 678
----------------------------------------
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }


	    		}

----------------------------------------
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }
	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805798
net/sf/varscan/Coverage.java 224 239
net/sf/varscan/Somatic.java 665 678
----------------------------------------
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }


	    		}

----------------------------------------
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }
	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805792
net/sf/varscan/CallMpileup.java 917 932
net/sf/varscan/Somatic.java 665 678
----------------------------------------
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }


	    		}

----------------------------------------
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }
	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805795
net/sf/varscan/CallPileup.java 291 306
net/sf/varscan/Somatic.java 665 678
----------------------------------------
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }


	    		}

----------------------------------------
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }
	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805799
net/sf/varscan/CallMpileup.java 76 97
net/sf/varscan/Trio.java 81 102
----------------------------------------
		boolean indelsOnly = false;
		boolean strandFilter = true;
		String sampleList = "";

		if(callType.equals("CNS"))
		{
			// Set more rigorous parameters for consensus calling
			minVarFreq = 0.20;
			pValueThreshold = 0.01;
		}

		// Adjust parameters based on user input //

		try
		{
			if(params.containsKey("min-coverage"))
				 minCoverage = Integer.parseInt(params.get("min-coverage"));

			if(params.containsKey("min-reads2"))
				 minReads2 = Integer.parseInt(params.get("min-reads2"));

			if(params.containsKey("min-var-freq"))

----------------------------------------
		int adjustedMinReads2 = 2;
		boolean strandFilter = true;
		String sampleList = "";

		if(callType.equals("CNS"))
		{
			// Set more rigorous parameters for consensus calling
			minVarFreq = 0.20;
			pValueThreshold = 0.01;
		}

		// Adjust parameters based on user input //

		try
		{
			if(params.containsKey("min-coverage"))
				 minCoverage = Integer.parseInt(params.get("min-coverage"));

			if(params.containsKey("min-reads2"))
				 minReads2 = Integer.parseInt(params.get("min-reads2"));

			if(params.containsKey("adj-min-reads2"))

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805800
net/sf/varscan/CallMpileup.java 98 149
net/sf/varscan/Trio.java 115 170
----------------------------------------
				 minVarFreq = Double.parseDouble(params.get("min-var-freq"));

			if(params.containsKey("min-freq-for-hom"))
				 minFreqForHom = Double.parseDouble(params.get("min-freq-for-hom"));

			if(params.containsKey("min-avg-qual"))
				 minAvgQual = Integer.parseInt(params.get("min-avg-qual"));

			if(params.containsKey("p-value"))
				 pValueThreshold = Double.parseDouble(params.get("p-value"));

			if(params.containsKey("strand-filter"))
			{
				int filter = Integer.parseInt(params.get("strand-filter"));
				if(filter > 0)
					strandFilter = true;
				else
					strandFilter = false;
			}

			if(params.containsKey("vcf-sample-list"))
			{
				File samplefile = new File(params.get("vcf-sample-list"));
				// Parse sample list //
				if(samplefile.exists())
	    		{
	    			BufferedReader in = new BufferedReader(new FileReader(samplefile));
	    			String line = "";
	    			if(in.ready())
	    			{
	    				while ((line = in.readLine()) != null)
	    				{
	    					String sampleName = line;
	    					if(sampleList.length() > 0)
	    						sampleList += "\t";
	    					sampleList += sampleName;
	    				}
	    			}
	    			else
	    			{
	    				System.err.println("Unable to open sample list");
	    			}

	    			in.close();
	    		}

				System.err.println("Got the following sample list: ");
				System.err.println(sampleList);
			}


			if(params.containsKey("variants"))

----------------------------------------
				 adjustedpValueThreshold = Double.parseDouble(params.get("adj-p-value"));

			if(params.containsKey("min-freq-for-hom"))
				 minFreqForHom = Double.parseDouble(params.get("min-freq-for-hom"));

			if(params.containsKey("min-avg-qual"))
				 minAvgQual = Integer.parseInt(params.get("min-avg-qual"));

			if(params.containsKey("output-name"))
			{
				outputName = params.get("output-name");
				outputSnp = outputName + ".snp.vcf";
				outputIndel = outputName + ".indel.vcf";

			}

			if(params.containsKey("strand-filter"))
			{
				int filter = Integer.parseInt(params.get("strand-filter"));
				if(filter > 0)
					strandFilter = true;
				else
					strandFilter = false;
			}

			if(params.containsKey("vcf-sample-list"))
			{
				File samplefile = new File(params.get("vcf-sample-list"));
				// Parse sample list //
				if(samplefile.exists())
	    		{
	    			BufferedReader in = new BufferedReader(new FileReader(samplefile));
	    			String line = "";
	    			if(in.ready())
	    			{
	    				while ((line = in.readLine()) != null)
	    				{
	    					String sampleName = line;
	    					if(sampleList.length() > 0)
	    						sampleList += "\t";
	    					sampleList += sampleName;
	    				}
	    			}
	    			else
	    			{
	    				System.err.println("Unable to open sample list");
	    			}

	    			in.close();
	    		}

				System.err.println("Got the following sample list: ");
				System.err.println(sampleList);
			}

			if(params.containsKey("p-value"))

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805801
net/sf/varscan/CallMpileup.java 209 311
net/sf/varscan/Trio.java 229 338
----------------------------------------
		int numParsingExceptions = 0;

		// Parse piped input or user-provided pileup file //

	    try
	    {

	    	// Declare file-parsing variables //

	    	BufferedReader in = VarScan.getInfile(args);
	    	String line;

	    	// If no input, print usage //

	    	if(in == null)
	    	{
	    		System.out.println(usage);
				return;
	    	}

	    	// If input file not ready, give it a few seconds //
	    	int numNaps = 0;

	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

	    	// Proceed if input stream is ready //
			String vcfHeader = "##fileformat=VCFv4.1";

	    	if(in != null && in.ready())
	    	{
	    		// Print a file header //
	    		if(!params.containsKey("no-headers"))
	    		{
	    			if(params.containsKey("output-vcf"))
	    			{
	    				// Output VCF Header //

	    				vcfHeader += "\n" + "##source=VarScan2";
	    				vcfHeader += "\n" + "##INFO=<ID=ADP,Number=1,Type=Integer,Description=\"Average per-sample depth of bases with Phred score >= " + minAvgQual + "\">";
	    				vcfHeader += "\n" + "##INFO=<ID=WT,Number=1,Type=Integer,Description=\"Number of samples called reference (wild-type)\">";
	    				vcfHeader += "\n" + "##INFO=<ID=HET,Number=1,Type=Integer,Description=\"Number of samples called heterozygous-variant\">";
	    				vcfHeader += "\n" + "##INFO=<ID=HOM,Number=1,Type=Integer,Description=\"Number of samples called homozygous-variant\">";
	    				vcfHeader += "\n" + "##INFO=<ID=NC,Number=1,Type=Integer,Description=\"Number of samples not called\">";
	    				vcfHeader += "\n" + "##FILTER=<ID=str10,Description=\"Less than 10% or more than 90% of variant supporting reads on one strand\">";
	    				vcfHeader += "\n" + "##FILTER=<ID=indelError,Description=\"Likely artifact due to indel reads at this position\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=GT,Number=1,Type=String,Description=\"Genotype\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=GQ,Number=1,Type=Integer,Description=\"Genotype Quality\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=SDP,Number=1,Type=Integer,Description=\"Raw Read Depth as reported by SAMtools\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=DP,Number=1,Type=Integer,Description=\"Quality Read Depth of bases with Phred score >= " + minAvgQual + "\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=RD,Number=1,Type=Integer,Description=\"Depth of reference-supporting bases (reads1)\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=AD,Number=1,Type=Integer,Description=\"Depth of variant-supporting bases (reads2)\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=FREQ,Number=1,Type=String,Description=\"Variant allele frequency\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=PVAL,Number=1,Type=String,Description=\"P-value from Fisher's Exact Test\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=RBQ,Number=1,Type=Integer,Description=\"Average quality of reference-supporting bases (qual1)\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=ABQ,Number=1,Type=Integer,Description=\"Average quality of variant-supporting bases (qual2)\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=RDF,Number=1,Type=Integer,Description=\"Depth of reference-supporting bases on forward strand (reads1plus)\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=RDR,Number=1,Type=Integer,Description=\"Depth of reference-supporting bases on reverse strand (reads1minus)\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=ADF,Number=1,Type=Integer,Description=\"Depth of variant-supporting bases on forward strand (reads2plus)\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=ADR,Number=1,Type=Integer,Description=\"Depth of variant-supporting bases on reverse strand (reads2minus)\">";

	    			}
	    			else
	    			{
	    				// Output VarScan Header //
		    			System.out.println("Chrom\tPosition\tRef\tVar\tCons:Cov:Reads1:Reads2:Freq:P-value\tStrandFilter:R1+:R1-:R2+:R2-:pval\tSamplesRef\tSamplesHet\tSamplesHom\tSamplesNC\tCons:Cov:Reads1:Reads2:Freq:P-value");
	    			}

	    		}



	    		// Parse the infile line by line //

	    		while ((line = in.readLine()) != null)
	    		{
	    			numBases++;//stats.put("numBases", (stats.get("numBases") + 1));

	    			// Output progress line //
	    			if(params.containsKey("verbose") && (numBases % 100000) == 0)
		        		System.err.println(numBases + " positions parsed...");

	    			// Begin try-catch for line parsing //

	    			try
	    			{
	    				String[] lineContents = line.split("\t", -1);

----------------------------------------
		HashMap<String, Integer> stats = new HashMap<String, Integer>();

		// Parse piped input or user-provided pileup file //

	    try
	    {

	    	// Declare file-parsing variables //

	    	BufferedReader in = VarScan.getInfile(args);
	    	String line;

	    	// If no input, print usage //

	    	if(in == null)
	    	{
	    		System.out.println(usage);
				return;
	    	}

	    	// If input file not ready, give it a few seconds //
	    	int numNaps = 0;

	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

	    	// Proceed if input stream is ready //
			String vcfHeader = "##fileformat=VCFv4.1";

	    	if(in != null && in.ready())
	    	{
				// Declare output file //
		 	 	PrintStream outSnp = null; // declare a print stream object for SNPs
		 	 	PrintStream outIndel = null; // declare a print stream object for Indels

		 		outSnp = new PrintStream( new FileOutputStream(outputSnp) );
		 		outIndel = new PrintStream( new FileOutputStream(outputIndel) );

	    		// Print a file header //
	    		if(!params.containsKey("no-headers"))
	    		{
	    			if(params.containsKey("output-vcf"))
	    			{
	    				// Output VCF Header //

	    				vcfHeader += "\n" + "##source=VarScan2";
	    				vcfHeader += "\n" + "##INFO=<ID=ADP,Number=1,Type=Integer,Description=\"Average per-sample depth of bases with Phred score >= " + minAvgQual + "\">";
	    				vcfHeader += "\n" + "##INFO=<ID=STATUS,Number=1,Type=String,Description=\"Variant status in trio (1=untransmitted, 2=transmitted, 3=denovo, 4=MIE)\">";
	    				vcfHeader += "\n" + "##INFO=<ID=DENOVO,Number=0,Type=Flag,Description=\"Indicates apparent de novo mutations unique to the child\">";
	    				vcfHeader += "\n" + "##FILTER=<ID=str10,Description=\"Less than 10% or more than 90% of variant supporting reads on one strand\">";
	    				vcfHeader += "\n" + "##FILTER=<ID=indelError,Description=\"Likely artifact due to indel reads at this position\">";
	    				vcfHeader += "\n" + "##FILTER=<ID=mendelError,Description=\"Apparent Mendelian inheritance error (MIE) in trio\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=GT,Number=1,Type=String,Description=\"Genotype\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=GQ,Number=1,Type=Integer,Description=\"Genotype Quality\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=SDP,Number=1,Type=Integer,Description=\"Raw Read Depth as reported by SAMtools\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=DP,Number=1,Type=Integer,Description=\"Quality Read Depth of bases with Phred score >= " + minAvgQual + "\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=RD,Number=1,Type=Integer,Description=\"Depth of reference-supporting bases (reads1)\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=AD,Number=1,Type=Integer,Description=\"Depth of variant-supporting bases (reads2)\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=FREQ,Number=1,Type=String,Description=\"Variant allele frequency\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=PVAL,Number=1,Type=String,Description=\"P-value from Fisher's Exact Test\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=RBQ,Number=1,Type=Integer,Description=\"Average quality of reference-supporting bases (qual1)\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=ABQ,Number=1,Type=Integer,Description=\"Average quality of variant-supporting bases (qual2)\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=RDF,Number=1,Type=Integer,Description=\"Depth of reference-supporting bases on forward strand (reads1plus)\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=RDR,Number=1,Type=Integer,Description=\"Depth of reference-supporting bases on reverse strand (reads1minus)\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=ADF,Number=1,Type=Integer,Description=\"Depth of variant-supporting bases on forward strand (reads2plus)\">";
	    				vcfHeader += "\n" + "##FORMAT=<ID=ADR,Number=1,Type=Integer,Description=\"Depth of variant-supporting bases on reverse strand (reads2minus)\">";


	    			}
	    			else
	    			{
	    				// Output VarScan Header //
		    			System.out.println("Chrom\tPosition\tRef\tVar\tStrandFilter:R1+:R1-:R2+:R2-:pval\tFather:Cov:Reads1:Reads2:Freq:P-value\tMother:Cov:Reads1:Reads2:Freq:P-value\tChild:Cov:Reads1:Reads2:Freq:P-value");
	    			}

	    		}



	    		// Parse the infile line by line //

	    		while ((line = in.readLine()) != null)
	    		{
	    			numBases++;//stats.put("numBases", (stats.get("numBases") + 1));

	    			// Output progress line //
	    			if(params.containsKey("verbose") && (numBases % 100000) == 0)
		        		System.err.println(numBases + " positions parsed...");

	    			// Begin try-catch for line parsing //

	    			try
	    			{
	    				String[] lineContents = line.split("\t");

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805802
net/sf/varscan/CallMpileup.java 415 418
net/sf/varscan/Trio.java 413 416
----------------------------------------
			    	        				int reads1plus = Integer.parseInt(callContents[11]);
			    	        				int reads1minus = Integer.parseInt(callContents[12]);
			    	        				int reads2plus = Integer.parseInt(callContents[13]);
			    	        				int reads2minus = Integer.parseInt(callContents[14]);

----------------------------------------
			        				int reads1plus = Integer.parseInt(callContents[11]);
			        				int reads1minus = Integer.parseInt(callContents[12]);
			        				int reads2plus = Integer.parseInt(callContents[13]);
			        				int reads2minus = Integer.parseInt(callContents[14]);

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805803
net/sf/varscan/CallMpileup.java 740 759
net/sf/varscan/Trio.java 863 906
----------------------------------------
	    							avgQualityDepth = qualityDepth / (samplesRef + samplesHet + samplesHom + samplesUncalled);

	    						String refColumn = "";
	    						String varColumn = "";

	    						// Handle complex positions with multiple alleles including at least one indel //

	    						if(varBases.contains(",") && (varBases.contains("-") || varBases.contains("+")))
	    						{
	    							// Multi-allele indel //
	    							int maxDelSize = 0;
	    							String maxDelBases = "";
	    							// Go through each varAllele to find longest deletion //
	    							String[] varBaseContents = varBases.split(",");
	    							for(String varAllele : varBaseContents)
	    							{
	    								if(varAllele.startsWith("-"))
	    								{
	    									varAllele = varAllele.replace("-", "");
	    									if(varAllele.length() > maxDelSize)

----------------------------------------
		    						int avgQualityDepth = (fatherQualityDepth + motherQualityDepth + childQualityDepth) / 3;
		    						String refColumn = "";
		    						String varColumn = "";

		    						// Handle complex positions with multiple alleles including at least one indel //

		    						if(varBases.contains(",") && (varBases.contains("-") || varBases.contains("+")))
		    						{
		    							variantType = "INDEL";
		    							// Multi-allele indel //
		    							int maxDelSize = 0;
		    							String maxDelBases = "";
		    							// Go through each varAllele to find longest deletion //
		    							String[] varBaseContents = varBases.split(",");
		    							for(String varAllele : varBaseContents)
		    							{
		    								if(varAllele.startsWith("-"))
		    								{
		    									varAllele = varAllele.replace("-", "");
		    									if(varAllele.length() > maxDelSize)
		    									{
		    										maxDelBases = varAllele;
		    										maxDelSize = varAllele.length();
		    									}
		    								}
		    							}

		    							// Set refBase to maximum del //
		    							refColumn = refBase + maxDelBases;

		    							// Establish each allele in var Column //
		    							varColumn = "";

		    							for(String varAllele : varBaseContents)
		    							{
	    									if(varColumn.length() > 0)
	    										varColumn = varColumn + ",";

		    								if(varAllele.startsWith("-"))
		    								{
		    									varAllele = varAllele.replace("-", "");

		    									// For the smaller deletion, determine ref bases to add //
		    									if(varAllele.length() < maxDelSize)

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805804
net/sf/varscan/CallMpileup.java 750 810
net/sf/varscan/Trio.java 873 933
----------------------------------------
	    							int maxDelSize = 0;
	    							String maxDelBases = "";
	    							// Go through each varAllele to find longest deletion //
	    							String[] varBaseContents = varBases.split(",");
	    							for(String varAllele : varBaseContents)
	    							{
	    								if(varAllele.startsWith("-"))
	    								{
	    									varAllele = varAllele.replace("-", "");
	    									if(varAllele.length() > maxDelSize)
	    									{
	    										maxDelBases = varAllele;
	    										maxDelSize = varAllele.length();
	    									}
	    								}
	    							}

	    							// Set refBase to maximum del //
	    							refColumn = refBase + maxDelBases;

	    							// Establish each allele in var Column //
	    							varColumn = "";

	    							for(String varAllele : varBaseContents)
	    							{
    									if(varColumn.length() > 0)
    										varColumn = varColumn + ",";

	    								if(varAllele.startsWith("-"))
	    								{
	    									varAllele = varAllele.replace("-", "");

	    									// For the smaller deletion, determine ref bases to add //
	    									if(varAllele.length() < maxDelSize)
	    									{
	    										String varEntry = maxDelBases.replace(varAllele, "");
	    										varColumn = varColumn + refBase + varEntry;
	    									}
	    									else
	    									{
	    										varColumn = varColumn + refBase;
	    									}
	    								}
	    								else if(varAllele.startsWith("+"))
	    								{
	    									varAllele = varAllele.replace("+", "");
	    									String varEntry = refBase + varAllele + maxDelBases;
	    									varColumn = varColumn + varEntry;
	    								}
	    								else
	    								{
	    									String varEntry = varAllele + maxDelBases;
	    									varColumn = varColumn + varEntry;
	    								}
	    							}


	    						}

	    						else if(varBases.startsWith("+"))
		    					{

----------------------------------------
		    							int maxDelSize = 0;
		    							String maxDelBases = "";
		    							// Go through each varAllele to find longest deletion //
		    							String[] varBaseContents = varBases.split(",");
		    							for(String varAllele : varBaseContents)
		    							{
		    								if(varAllele.startsWith("-"))
		    								{
		    									varAllele = varAllele.replace("-", "");
		    									if(varAllele.length() > maxDelSize)
		    									{
		    										maxDelBases = varAllele;
		    										maxDelSize = varAllele.length();
		    									}
		    								}
		    							}

		    							// Set refBase to maximum del //
		    							refColumn = refBase + maxDelBases;

		    							// Establish each allele in var Column //
		    							varColumn = "";

		    							for(String varAllele : varBaseContents)
		    							{
	    									if(varColumn.length() > 0)
	    										varColumn = varColumn + ",";

		    								if(varAllele.startsWith("-"))
		    								{
		    									varAllele = varAllele.replace("-", "");

		    									// For the smaller deletion, determine ref bases to add //
		    									if(varAllele.length() < maxDelSize)
		    									{
		    										String varEntry = maxDelBases.replace(varAllele, "");
		    										varColumn = varColumn + refBase + varEntry;
		    									}
		    									else
		    									{
		    										varColumn = varColumn + refBase;
		    									}
		    								}
		    								else if(varAllele.startsWith("+"))
		    								{
		    									varAllele = varAllele.replace("+", "");
		    									String varEntry = refBase + varAllele + maxDelBases;
		    									varColumn = varColumn + varEntry;
		    								}
		    								else
		    								{
		    									String varEntry = varAllele + maxDelBases;
		    									varColumn = varColumn + varEntry;
		    								}
		    							}


		    						}

		    						else if(varBases.startsWith("+"))
			    					{

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805805
net/sf/varscan/CallMpileup.java 813 834
net/sf/varscan/Trio.java 937 962
----------------------------------------
	    							refColumn = refBase;
		    						varColumn = refBase + varBases.replace("+", "");
		    					}
		    					else if(varBases.startsWith("-"))
		    					{
		    						// DELETION //
		    						// Ref = ref base followed by deleted bases; var = ref base //
		    						refColumn = refBase + varBases.replace("-", "");
		    						varColumn = refBase;
		    					}
		    					else
		    					{
		    						refColumn = refBase;
		    						varColumn = varBases;
		    					}

	    						// Ensure that varColumn does not contain any +/- //
	    						varColumn = varColumn.replace("+", "");
	    						varColumn = varColumn.replace("-", "");


	    						outLine += "." + "\t" + refColumn + "\t" + varColumn + "\t.\t";

----------------------------------------
		    							refColumn = refBase;
			    						varColumn = refBase + varBases.replace("+", "");
			    					}
			    					else if(varBases.startsWith("-"))
			    					{
			    						variantType = "INDEL";
			    						// DELETION //
			    						// Ref = ref base followed by deleted bases; var = ref base //
			    						refColumn = refBase + varBases.replace("-", "");
			    						varColumn = refBase;
			    					}
			    					else
			    					{
			    						// Variant type SNP //
			    						refColumn = refBase;
			    						varColumn = varBases;
			    					}


		    						// Ensure that varColumn does not contain any +/- //
		    						varColumn = varColumn.replace("+", "");
		    						varColumn = varColumn.replace("-", "");

		    						// ADD REF, ALT, FILTER, INFO, and FORMAT FIELDS TO OUTPUT //

		    						outLine += "." + "\t" + refColumn + "\t" + varColumn + "\t.\t";

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805806
net/sf/varscan/CallMpileup.java 902 939
net/sf/varscan/Trio.java 1075 1116
----------------------------------------
    						}

	    				}
	    				else
	    				{
	    					if(lineContents.length >= 4 && lineContents[3].equals("0"))
	    					{
	    						// A pileup line with 0x coverage, so ignore
	    					}
	    					else
	    					{
		    					System.err.println("Warning: Line ignored: Invalid format for pileup at line " + numBases + "\n" + line + "\n");
		    					return;
	    					}

	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }


	    		}

				in.close();

				System.err.println(numBases + " bases in pileup file");
				System.err.println(numVariantPositions + " variant positions (" + numSNPpositions + " SNP, " + numIndelPositions + " indel)");
				System.err.println(numFailStrandFilter + " were failed by the strand-filter");
				System.err.println(numVariantsReported + " variant positions reported (" + numSNPsReported + " SNP, " + numIndelsReported + " indel)");

----------------------------------------
	    	        		}



	    				}
	    				else
	    				{
	    					if(lineContents.length >= 4 && lineContents[3].equals("0"))
	    					{
	    						// A pileup line with 0x coverage, so ignore
	    					}
	    					else
	    					{
		    					System.err.println("Error: Invalid format for pileup at line " + numBases + "\n" + line + "\n");
		    					return;
	    					}

	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getMessage() + "\n" + e.getLocalizedMessage());
	    		    	e.printStackTrace();
	    		    	numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }


	    		}

				in.close();

				System.err.println(numBases + " bases in pileup file");
				System.err.println(numBasesCovered + " met the coverage requirement of " + minCoverage);
				System.err.println(numVariantPositions + " variant positions (" + numSNPpositions + " SNP, " + numIndelPositions + " indel)");
				System.err.println(numFailStrandFilter + " were failed by the strand-filter");
				System.err.println(numVariantsReported + " variant positions reported (" + numSNPsReported + " SNP, " + numIndelsReported + " indel)");

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805807
net/sf/varscan/Copynumber.java 307 330
net/sf/varscan/Copynumber.java 337 363
----------------------------------------
	    	    					copyPositions++;
	    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
	    	    						copyPositionsGC++;
	    	    					copyStop = posTumor;
	    	    				}

	    	    				// Otherwise, process this region (if it qualifies) and start a new one //

	    	    				else
	    	    				{
	    	    					if(copyPositions >= minSegmentSize)
	    	    					{
	    	    						rawCopySegments++;
	    	    						String regionResults = processCopyRegion(copyChrom, copyStart, copyStop, copyPositions, copyPositionsGC, copySumNormal, copySumTumor, minCoverage, dataRatio);

	    	    						if(regionResults.length() > 0)
	    	    						{
	    	    							outCopySegments.println(regionResults);
	    	    							goodCopySegments++;
	    	    						}
	    	    					}

	    	    					// Start a new copyNumber region //
	    	    					copyChrom = chromTumor;

----------------------------------------
	    	    					copyPositions = 1;
	    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
	    	    						copyPositionsGC = 1;
	    	    					else
	    	    						copyPositionsGC = 0;
	    	    				}


	    					}
	    					else
	    					{
	    						// If minimum coverage was not met, print region //
		    					// If we had a copyNumber region that met minimum coverage, report it //
		    					if(copyPositions >= minSegmentSize)
		    					{
		    						rawCopySegments++;
		    						String regionResults = processCopyRegion(copyChrom, copyStart, copyStop, copyPositions, copyPositionsGC, copySumNormal, copySumTumor, minCoverage, dataRatio);

		    						if(regionResults.length() > 0)
		    						{
		    							outCopySegments.println(regionResults);
		    							goodCopySegments++;
		    						}
		    					}

		    					// Reset the copyNumber region //
		    					copyChrom = "";

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805808
net/sf/varscan/Copynumber.java 307 330
net/sf/varscan/Copynumber.java 830 853
----------------------------------------
	    	    					copyPositions++;
	    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
	    	    						copyPositionsGC++;
	    	    					copyStop = posTumor;
	    	    				}

	    	    				// Otherwise, process this region (if it qualifies) and start a new one //

	    	    				else
	    	    				{
	    	    					if(copyPositions >= minSegmentSize)
	    	    					{
	    	    						rawCopySegments++;
	    	    						String regionResults = processCopyRegion(copyChrom, copyStart, copyStop, copyPositions, copyPositionsGC, copySumNormal, copySumTumor, minCoverage, dataRatio);

	    	    						if(regionResults.length() > 0)
	    	    						{
	    	    							outCopySegments.println(regionResults);
	    	    							goodCopySegments++;
	    	    						}
	    	    					}

	    	    					// Start a new copyNumber region //
	    	    					copyChrom = chromTumor;

----------------------------------------
    	    					copyPositions++;
    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
    	    						copyPositionsGC++;
    	    					copyStop = posTumor;
    	    				}

    	    				// Otherwise, process this region (if it qualifies) and start a new one //

    	    				else
    	    				{
    	    					if(copyPositions >= minSegmentSize)
    	    					{
    	    						rawCopySegments++;
    	    						String regionResults = processCopyRegion(copyChrom, copyStart, copyStop, copyPositions, copyPositionsGC, copySumNormal, copySumTumor, minCoverage, dataRatio);

    	    						if(regionResults.length() > 0)
    	    						{
    	    							outCopySegments.println(regionResults);
    	    							goodCopySegments++;
    	    						}
    	    					}

    	    					// Start a new copyNumber region //
    	    					copyChrom = chromTumor;

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805810
net/sf/varscan/Copynumber.java 337 363
net/sf/varscan/Copynumber.java 830 853
----------------------------------------
	    	    					copyPositions = 1;
	    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
	    	    						copyPositionsGC = 1;
	    	    					else
	    	    						copyPositionsGC = 0;
	    	    				}


	    					}
	    					else
	    					{
	    						// If minimum coverage was not met, print region //
		    					// If we had a copyNumber region that met minimum coverage, report it //
		    					if(copyPositions >= minSegmentSize)
		    					{
		    						rawCopySegments++;
		    						String regionResults = processCopyRegion(copyChrom, copyStart, copyStop, copyPositions, copyPositionsGC, copySumNormal, copySumTumor, minCoverage, dataRatio);

		    						if(regionResults.length() > 0)
		    						{
		    							outCopySegments.println(regionResults);
		    							goodCopySegments++;
		    						}
		    					}

		    					// Reset the copyNumber region //
		    					copyChrom = "";

----------------------------------------
    	    					copyPositions++;
    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
    	    						copyPositionsGC++;
    	    					copyStop = posTumor;
    	    				}

    	    				// Otherwise, process this region (if it qualifies) and start a new one //

    	    				else
    	    				{
    	    					if(copyPositions >= minSegmentSize)
    	    					{
    	    						rawCopySegments++;
    	    						String regionResults = processCopyRegion(copyChrom, copyStart, copyStop, copyPositions, copyPositionsGC, copySumNormal, copySumTumor, minCoverage, dataRatio);

    	    						if(regionResults.length() > 0)
    	    						{
    	    							outCopySegments.println(regionResults);
    	    							goodCopySegments++;
    	    						}
    	    					}

    	    					// Start a new copyNumber region //
    	    					copyChrom = chromTumor;

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
26805809
net/sf/varscan/Copynumber.java 307 330
net/sf/varscan/Copynumber.java 860 886
----------------------------------------
	    	    					copyPositions++;
	    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
	    	    						copyPositionsGC++;
	    	    					copyStop = posTumor;
	    	    				}

	    	    				// Otherwise, process this region (if it qualifies) and start a new one //

	    	    				else
	    	    				{
	    	    					if(copyPositions >= minSegmentSize)
	    	    					{
	    	    						rawCopySegments++;
	    	    						String regionResults = processCopyRegion(copyChrom, copyStart, copyStop, copyPositions, copyPositionsGC, copySumNormal, copySumTumor, minCoverage, dataRatio);

	    	    						if(regionResults.length() > 0)
	    	    						{
	    	    							outCopySegments.println(regionResults);
	    	    							goodCopySegments++;
	    	    						}
	    	    					}

	    	    					// Start a new copyNumber region //
	    	    					copyChrom = chromTumor;

----------------------------------------
    	    					copyPositions = 1;
    	    					if(refBase.equals("G") || refBase.equals("C") || refBase.equals("g") || refBase.equals("c"))
    	    						copyPositionsGC = 1;
    	    					else
    	    						copyPositionsGC = 0;
    	    				}


    					}
    					else
    					{
    						// If minimum coverage was not met, print region //
	    					// If we had a copyNumber region that met minimum coverage, report it //
	    					if(copyPositions >= minSegmentSize)
	    					{
	    						rawCopySegments++;
	    						String regionResults = processCopyRegion(copyChrom, copyStart, copyStop, copyPositions, copyPositionsGC, copySumNormal, copySumTumor, minCoverage, dataRatio);

	    						if(regionResults.length() > 0)
	    						{
	    							outCopySegments.println(regionResults);
	    							goodCopySegments++;
	    						}
	    					}

	    					// Reset the copyNumber region //
	    					copyChrom = "";

----------------------------------------
