$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418738
net/sf/varscan/Copynumber.java 1067 1107
net/sf/varscan/Somatic.java 1926 1967
----------------------------------------
		return false;
	}



	/**
	 * Determines the sort order for chromosomes
	 *
	 * @param	args	Command-line arguments
	 * @return			HashMap of parameter names and their values
	 */
	static Boolean chromSorted(String chrom1, String chrom2)
	{
		Boolean answer = false;

		chrom1.replace("X", "23");
		chrom1.replace("Y", "24");
		chrom1.replace("M", "25");

		chrom2.replace("X", "23");
		chrom2.replace("Y", "24");
		chrom2.replace("M", "25");

		String[] unsorted = {chrom1, chrom2};
		String[] sorted = {chrom1, chrom2};
		Arrays.sort(sorted);
		System.err.println("Sorted order is " + sorted[0] + " " + sorted[1]);
		try{
			if(sorted[0].equals(unsorted[0]))
			{
				answer = true;
			}
		}
		catch(Exception e)
		{

		}

		return(answer);
	}
}

----------------------------------------
		 return("");	// No call
	}



	/**
	 * Determines the sort order for chromosomes
	 *
	 * @param	args	Command-line arguments
	 * @return			HashMap of parameter names and their values
	 */
	static Boolean chromSorted(String chrom1, String chrom2)
	{
		Boolean answer = false;

		chrom1.replace("X", "23");
		chrom1.replace("Y", "24");
		chrom1.replace("M", "25");

		chrom2.replace("X", "23");
		chrom2.replace("Y", "24");
		chrom2.replace("M", "25");

		String[] unsorted = {chrom1, chrom2};
		String[] sorted = {chrom1, chrom2};
		Arrays.sort(sorted);
		System.err.println("Sorted order is " + sorted[0] + " " + sorted[1]);
		try{
			if(sorted[0].equals(unsorted[0]))
			{
				answer = true;
			}
		}
		catch(Exception e)
		{

		}

		return(answer);
	}

}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418739
net/sf/varscan/Copynumber.java 205 213
net/sf/varscan/ReadCounts.java 155 163
----------------------------------------
	    			try
	    			{
	    				String[] lineContents = line.split("\t");

	    				// Verify expected pileup format //

	    				if(lineContents.length > 5 && lineContents[0].length() > 0 && lineContents[1].length() > 0 && lineContents[2].length() > 0 && lineContents[3].length() > 0)
	    				{
	    					sharedPositions++;

----------------------------------------
	    			try
	    			{
	    				String[] lineContents = line.split("\t");

	    				// Verify expected pileup format //

	    				if(lineContents.length > 5 && lineContents[0].length() > 0 && lineContents[1].length() > 0 && lineContents[2].length() > 0 && lineContents[3].length() > 0)
	    				{
	    					String refName = lineContents[0];

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418740
net/sf/varscan/Copynumber.java 205 213
net/sf/varscan/Coverage.java 154 162
----------------------------------------
	    			try
	    			{
	    				String[] lineContents = line.split("\t");

	    				// Verify expected pileup format //

	    				if(lineContents.length > 5 && lineContents[0].length() > 0 && lineContents[1].length() > 0 && lineContents[2].length() > 0 && lineContents[3].length() > 0)
	    				{
	    					sharedPositions++;

----------------------------------------
	    			try
	    			{
	    				String[] lineContents = line.split("\t");

	    				// Verify expected pileup format //

	    				if(lineContents.length > 5 && lineContents[0].length() > 0 && lineContents[1].length() > 0 && lineContents[2].length() > 0 && lineContents[3].length() > 0)
	    				{
	    					String refName = lineContents[0];

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418741
net/sf/varscan/CallPileup.java 181 187
net/sf/varscan/Copynumber.java 207 213
----------------------------------------
	    				String[] lineContents = line.split("\t", -1);

	    				// Verify expected pileup format //

	    				if(lineContents.length > 5 && lineContents[0].length() > 0 && lineContents[1].length() > 0 && lineContents[2].length() > 0 && lineContents[3].length() > 0)
	    				{
	    					String refName = "";

----------------------------------------
	    				String[] lineContents = line.split("\t");

	    				// Verify expected pileup format //

	    				if(lineContents.length > 5 && lineContents[0].length() > 0 && lineContents[1].length() > 0 && lineContents[2].length() > 0 && lineContents[3].length() > 0)
	    				{
	    					sharedPositions++;

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418742
net/sf/varscan/CallMpileup.java 339 341
net/sf/varscan/Copynumber.java 211 213
----------------------------------------
	    				if(lineContents.length > 5 && lineContents[0].length() > 0 && lineContents[1].length() > 0 && lineContents[2].length() > 0 && lineContents[3].length() > 0)
	    				{
	    					String refName = lineContents[0];

----------------------------------------
	    				if(lineContents.length > 5 && lineContents[0].length() > 0 && lineContents[1].length() > 0 && lineContents[2].length() > 0 && lineContents[3].length() > 0)
	    				{
	    					sharedPositions++;

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418743
net/sf/varscan/Copynumber.java 120 162
net/sf/varscan/Somatic.java 236 278
----------------------------------------
	    try
	    {
	    	// Declare file-parsing variables //

	    	BufferedReader in = VarScan.getInfile(args);
	    	String line;

	    	// If no input, print usage //

	    	if(in == null)
	    	{
	    		System.out.println(usage);
				return;
	    	}

	    	// If input file not ready, give it a few seconds //
	    	int numNaps = 0;

	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

	    	// Proceed if input stream is ready //

	    	if(in != null && in.ready())
	    	{
				// Declare output file //
		 	 	PrintStream outCopySegments = null; // declare a print stream object for copynumber segments

----------------------------------------
		try
		{
	    	// Declare file-parsing variables //

	    	BufferedReader in = VarScan.getInfile(args);
	    	String line;

	    	// If no input, print usage //

	    	if(in == null)
	    	{
	    		System.out.println(usage);
				return;
	    	}

	    	// If input file not ready, give it a few seconds //
	    	int numNaps = 0;

	    	while(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

	    	// Proceed if input stream is ready //

	    	if(in != null && in.ready())
	    	{
	    		// Declare some file-parsing variables //
			    String lineNormal;

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418744
net/sf/varscan/FilterVariants.java 561 582
net/sf/varscan/FilterSomatic.java 434 455
----------------------------------------
        					String position = lineContents[1];
        					String indelKey = chrom + "\t" + position;
        					indels.put(indelKey, Boolean.TRUE);
    					}

    				}
    			}
    			else
    			{
    				System.err.println("Unable to open indels file for reading");
    			}

    			in.close();
    		}
	    }
	    catch(Exception e)
	    {
	    	System.err.println("Error Parsing Indel File: " + e.getLocalizedMessage());
	    }

	    return(indels);
	}

----------------------------------------
	    					String position = lineContents[1];
	    					String indelKey = chrom + "\t" + position;
	    					indels.put(indelKey, Boolean.TRUE);
    					}

    				}
    			}
    			else
    			{
    				System.err.println("Unable to open indels file for reading");
    			}

    			in.close();
    		}
	    }
	    catch(Exception e)
	    {
	    	System.err.println("Error Parsing Indel File: " + e.getLocalizedMessage());
	    }

	    return(indels);
	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418745
net/sf/varscan/FilterVariants.java 507 552
net/sf/varscan/FilterSomatic.java 380 425
----------------------------------------
	    		System.err.println(stats.get("numFailPvalue") + " failed P-value > " + pValueThreshold);
	    		System.err.println(stats.get("numNearIndel") + " were removed near indels");
	    		System.err.println(stats.get("numPassFilter") + " passed filters");

	    		in.close();
	    	}
	    	else
	    	{
	    		System.err.println("Input file not found!");
	    		System.err.println(usage);
	    	}
	    }
	    catch(Exception e)
	    {
	    	System.err.println("Error Parsing Input File: " + e.getLocalizedMessage());
	    	e.printStackTrace(System.err);
	    	return;
	    }
	}


	/**
	 * Loads indels to be used for filtering
	 *
	 * @param	filename	Path to file of indels
	 * @return	indels		HashMap of indel positions (chrom\tposition)
	 */
	static HashMap<String, Boolean> loadIndels(String filename)
	{
    	HashMap<String, Boolean> indels = new HashMap<String, Boolean>();

	    try
	    {
	    	// Declare file-parsing variables //

	    	String line;

    		File infile = new File(filename);
    		if(infile.exists())
    		{
    			BufferedReader in = new BufferedReader(new FileReader(infile));

    			if(in.ready())
    			{
    				while ((line = in.readLine()) != null)
    				{

----------------------------------------
	    		System.err.println(stats.get("numSNPcluster") + " in SNP clusters were removed");
	    		System.err.println(stats.get("numNearIndel") + " were removed near indels");
	    		System.err.println(stats.get("numPassFilter") + " passed filters");

	    		in.close();
	    	}
	    	else
	    	{
	    		System.err.println("Input file not found!");
	    		System.err.println(usage);
	    	}
	    }
	    catch(Exception e)
	    {
	    	System.err.println("Error Parsing Input File: " + e.getLocalizedMessage());
	    	e.printStackTrace(System.err);
	    	return;
	    }
	}


	/**
	 * Loads indels to be used for filtering
	 *
	 * @param	filename	Path to file of indels
	 * @return	indels		HashMap of indel positions (chrom\tposition)
	 */
	static HashMap<String, Boolean> loadIndels(String filename)
	{
    	HashMap<String, Boolean> indels = new HashMap<String, Boolean>();

	    try
	    {
	    	// Declare file-parsing variables //

	    	String line;

    		File infile = new File(filename);
    		if(infile.exists())
    		{
    			BufferedReader in = new BufferedReader(new FileReader(infile));

    			if(in.ready())
    			{
    				while ((line = in.readLine()) != null)
    				{

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418746
net/sf/varscan/FilterVariants.java 523 552
net/sf/varscan/FpFilter.java 778 809
----------------------------------------
	    	return;
	    }
	}


	/**
	 * Loads indels to be used for filtering
	 *
	 * @param	filename	Path to file of indels
	 * @return	indels		HashMap of indel positions (chrom\tposition)
	 */
	static HashMap<String, Boolean> loadIndels(String filename)
	{
    	HashMap<String, Boolean> indels = new HashMap<String, Boolean>();

	    try
	    {
	    	// Declare file-parsing variables //

	    	String line;

    		File infile = new File(filename);
    		if(infile.exists())
    		{
    			BufferedReader in = new BufferedReader(new FileReader(infile));

    			if(in.ready())
    			{
    				while ((line = in.readLine()) != null)
    				{

----------------------------------------
	    	e.printStackTrace(System.err);
	    }


	}


	/**
	 * Loads snvs to be filtered
	 *
	 * @param	filename	Path to file of snvs
	 * @return	snvs		HashMap of SNV positions (chrom\tposition\alt)
	 */
	static HashMap<String, String> loadReadcounts(String filename)
	{
    	HashMap<String, String> readcounts = new HashMap<String, String>();

	    try
	    {
	    	// Declare file-parsing variables //

	    	String line;

    		File infile = new File(filename);
    		if(infile.exists())
    		{
    			BufferedReader in = new BufferedReader(new FileReader(infile));

    			if(in.ready())
    			{
    				while ((line = in.readLine()) != null)
    				{

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418748
net/sf/varscan/FilterVariants.java 137 147
net/sf/varscan/LimitVariants.java 102 112
----------------------------------------
			PrintStream outFile = null;
			if(params.containsKey("output-file"))
				outFile = new PrintStream( new FileOutputStream(outFileName) );

			PrintStream notFile = null;
			if(params.containsKey("not-file"))
				notFile = new PrintStream( new FileOutputStream(notFileName) );

	    	// Declare file-parsing variables //

	    	BufferedReader in = VarScan.getInfile(args);

----------------------------------------
			PrintStream outFile = null;
			if(params.containsKey("output-file"))
				outFile = new PrintStream( new FileOutputStream(outFileName) );

			// Declare not output file //
			PrintStream notFile = null;
			if(params.containsKey("not-file"))
				notFile = new PrintStream( new FileOutputStream(notFileName) );

	 	 	// Load target positions //
	 	 	HashMap<String, BitSet> targetHash = loadTargets(targetFileName, targetFileType, marginSize);

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418749
net/sf/varscan/CopyCaller.java 179 200
net/sf/varscan/ReadCounts.java 118 139
----------------------------------------
				return;
	    	}

	    	// If input file not ready, give it a few seconds //
	    	int numNaps = 0;

	    	if(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;
			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
	    		}
		    	catch(Exception e)
		    	{

		    	}
	    	}

----------------------------------------
	    		System.exit(10);
	    	}

	    	// If input file not ready, give it a few seconds //
	    	int numNaps = 0;

	    	if(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;
			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
	    		}
		    	catch(Exception e)
		    	{

		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418750
net/sf/varscan/CopyCaller.java 185 197
net/sf/varscan/ProcessSomatic.java 78 91
----------------------------------------
	    	if(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;
			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
	    		}
		    	catch(Exception e)
		    	{

----------------------------------------
	    	while(!infile.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418766
net/sf/varscan/ReadCounts.java 124 136
net/sf/varscan/ProcessSomatic.java 78 91
----------------------------------------
	    	if(!in.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;
			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
	    		}
		    	catch(Exception e)
		    	{

----------------------------------------
	    	while(!infile.ready())
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418751
net/sf/varscan/Coverage.java 331 383
net/sf/varscan/ProcessSomatic.java 347 399
----------------------------------------
		int numBases = 0;

		try
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{

----------------------------------------
		HashMap<String, BitSet> positionsByChrom = new HashMap<String, BitSet>();

		try
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418752
net/sf/varscan/Coverage.java 335 350
net/sf/varscan/Comparison.java 78 94
----------------------------------------
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

----------------------------------------
		    int uniqueToFile2 = 0;

		    // Parse the lines in file 1 //
		    String line = "";
		    int lineCounter = 0;

		    while ((line = file1.readLine()) != null)
		    {
		    	lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418771
net/sf/varscan/ReadCounts.java 157 163
net/sf/varscan/Somatic.java 338 344
----------------------------------------
	    				String[] lineContents = line.split("\t");

	    				// Verify expected pileup format //

	    				if(lineContents.length > 5 && lineContents[0].length() > 0 && lineContents[1].length() > 0 && lineContents[2].length() > 0 && lineContents[3].length() > 0)
	    				{
	    					String refName = lineContents[0];

----------------------------------------
	    				String[] lineContents = line.split("\t", -1);

	    				// Verify expected pileup format //

	    				if(lineContents.length > 5 && lineContents[0].length() > 0 && lineContents[1].length() > 0 && lineContents[2].length() > 0 && lineContents[3].length() > 0)
	    				{
	    					sharedPositions++;

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418753
net/sf/varscan/Coverage.java 156 162
net/sf/varscan/Somatic.java 338 344
----------------------------------------
	    				String[] lineContents = line.split("\t");

	    				// Verify expected pileup format //

	    				if(lineContents.length > 5 && lineContents[0].length() > 0 && lineContents[1].length() > 0 && lineContents[2].length() > 0 && lineContents[3].length() > 0)
	    				{
	    					String refName = lineContents[0];

----------------------------------------
	    				String[] lineContents = line.split("\t", -1);

	    				// Verify expected pileup format //

	    				if(lineContents.length > 5 && lineContents[0].length() > 0 && lineContents[1].length() > 0 && lineContents[2].length() > 0 && lineContents[3].length() > 0)
	    				{
	    					sharedPositions++;

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418755
net/sf/varscan/CallMpileup.java 299 311
net/sf/varscan/Coverage.java 144 156
----------------------------------------
	    		while ((line = in.readLine()) != null)
	    		{
	    			numBases++;//stats.put("numBases", (stats.get("numBases") + 1));

	    			// Output progress line //
	    			if(params.containsKey("verbose") && (numBases % 100000) == 0)
		        		System.err.println(numBases + " positions parsed...");

	    			// Begin try-catch for line parsing //

	    			try
	    			{
	    				String[] lineContents = line.split("\t", -1);

----------------------------------------
	    		while ((line = in.readLine()) != null)
	    		{
	    			lineCounter++;//stats.put("numBases", (stats.get("numBases") + 1));

	    			// Output progress line //
	    			if(params.containsKey("verbose") && (lineCounter % 100000) == 0)
		        		System.err.println(lineCounter + " positions parsed...");

	    			// Begin try-catch for line parsing //

	    			try
	    			{
	    				String[] lineContents = line.split("\t");

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418754
net/sf/varscan/CallPileup.java 169 181
net/sf/varscan/Coverage.java 144 156
----------------------------------------
	    		while ((line = in.readLine()) != null)
	    		{
	    			numBases++;//stats.put("numBases", (stats.get("numBases") + 1));

	    			// Output progress line //
	    			if(params.containsKey("verbose") && (numBases % 100000) == 0)
		        		System.err.println(numBases + " positions parsed...");

	    			// Begin try-catch for line parsing //

	    			try
	    			{
	    				String[] lineContents = line.split("\t", -1);

----------------------------------------
	    		while ((line = in.readLine()) != null)
	    		{
	    			lineCounter++;//stats.put("numBases", (stats.get("numBases") + 1));

	    			// Output progress line //
	    			if(params.containsKey("verbose") && (lineCounter % 100000) == 0)
		        		System.err.println(lineCounter + " positions parsed...");

	    			// Begin try-catch for line parsing //

	    			try
	    			{
	    				String[] lineContents = line.split("\t");

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418756
net/sf/varscan/FilterSomatic.java 396 426
net/sf/varscan/FpFilter.java 778 810
----------------------------------------
	    	return;
	    }
	}


	/**
	 * Loads indels to be used for filtering
	 *
	 * @param	filename	Path to file of indels
	 * @return	indels		HashMap of indel positions (chrom\tposition)
	 */
	static HashMap<String, Boolean> loadIndels(String filename)
	{
    	HashMap<String, Boolean> indels = new HashMap<String, Boolean>();

	    try
	    {
	    	// Declare file-parsing variables //

	    	String line;

    		File infile = new File(filename);
    		if(infile.exists())
    		{
    			BufferedReader in = new BufferedReader(new FileReader(infile));

    			if(in.ready())
    			{
    				while ((line = in.readLine()) != null)
    				{
    					String[] lineContents = line.split("\t");

----------------------------------------
	    	e.printStackTrace(System.err);
	    }


	}


	/**
	 * Loads snvs to be filtered
	 *
	 * @param	filename	Path to file of snvs
	 * @return	snvs		HashMap of SNV positions (chrom\tposition\alt)
	 */
	static HashMap<String, String> loadReadcounts(String filename)
	{
    	HashMap<String, String> readcounts = new HashMap<String, String>();

	    try
	    {
	    	// Declare file-parsing variables //

	    	String line;

    		File infile = new File(filename);
    		if(infile.exists())
    		{
    			BufferedReader in = new BufferedReader(new FileReader(infile));

    			if(in.ready())
    			{
    				while ((line = in.readLine()) != null)
    				{
    					String[] lineContents = line.split("\t");

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418757
net/sf/varscan/FilterSomatic.java 275 282
net/sf/varscan/ProcessSomatic.java 245 251
----------------------------------------
		    					tumorFreq = (double) tumorReads2 / (double) (tumorReads1 + tumorReads2);


		    				if(normalReads1 > 0 || normalReads2 > 0)
		    					normalFreq = (double) normalReads2 / (double) (normalReads1 + normalReads2);

		    				if(tumorReads1 > 0 || tumorReads2 > 0)
		    					tumorFreq = (double) tumorReads2 / (double) (tumorReads1 + tumorReads2);

----------------------------------------
		    				double tumorFreq = 0;

		    				if(normalReads1 > 0 || normalReads2 > 0)
		    					normalFreq = (double) normalReads2 / (double) (normalReads1 + normalReads2);

		    				if(tumorReads1 > 0 || tumorReads2 > 0)
		    					tumorFreq = (double) tumorReads2 / (double) (tumorReads1 + tumorReads2);

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418758
net/sf/varscan/ProcessSomatic.java 245 251
net/sf/varscan/FilterSomatic.java 269 275
----------------------------------------
		    				double tumorFreq = 0;

		    				if(normalReads1 > 0 || normalReads2 > 0)
		    					normalFreq = (double) normalReads2 / (double) (normalReads1 + normalReads2);

		    				if(tumorReads1 > 0 || tumorReads2 > 0)
		    					tumorFreq = (double) tumorReads2 / (double) (tumorReads1 + tumorReads2);

----------------------------------------
		    				int tumorCoverage = tumorReads1 + tumorReads2;

		    				if(normalReads1 > 0 || normalReads2 > 0)
		    					normalFreq = (double) normalReads2 / (double) (normalReads1 + normalReads2);

		    				if(tumorReads1 > 0 || tumorReads2 > 0)
		    					tumorFreq = (double) tumorReads2 / (double) (tumorReads1 + tumorReads2);

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418760
net/sf/varscan/ProcessSomatic.java 361 432
net/sf/varscan/LimitVariants.java 240 311
----------------------------------------
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}
		catch(Exception e)
		{
			System.err.println("ERROR: File Parsing Exception: " + e.getLocalizedMessage());
			e.printStackTrace(System.err);
		}


		return(positionsByChrom);
	}

}

----------------------------------------
	    		else if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}
		catch(Exception e)
		{
			System.err.println("ERROR: File Parsing Exception: " + e.getLocalizedMessage());
			e.printStackTrace(System.err);
		}


		return(positionsByChrom);
	}

}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418761
net/sf/varscan/ProcessSomatic.java 408 432
net/sf/varscan/Comparison.java 278 302
----------------------------------------
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}
		catch(Exception e)
		{
			System.err.println("ERROR: File Parsing Exception: " + e.getLocalizedMessage());
			e.printStackTrace(System.err);
		}


		return(positionsByChrom);
	}

}

----------------------------------------
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}
		catch(Exception e)
		{
			System.err.println("ERROR: File Parsing Exception: " + e.getLocalizedMessage());
			e.printStackTrace(System.err);
		}


		return(positionsByChrom);
	}

}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418762
net/sf/varscan/ProcessSomatic.java 408 432
net/sf/varscan/ReadCounts.java 389 412
----------------------------------------
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}
		catch(Exception e)
		{
			System.err.println("ERROR: File Parsing Exception: " + e.getLocalizedMessage());
			e.printStackTrace(System.err);
		}


		return(positionsByChrom);
	}

}

----------------------------------------
	    				variants.put(positionKey, allele1 + "\t" + allele2);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}
		catch(Exception e)
		{
			System.err.println("ERROR: File Parsing Exception: " + e.getLocalizedMessage());
			e.printStackTrace(System.err);
		}


		return(variants);
	}
}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418773
net/sf/varscan/Comparison.java 278 302
net/sf/varscan/ReadCounts.java 389 412
----------------------------------------
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}
		catch(Exception e)
		{
			System.err.println("ERROR: File Parsing Exception: " + e.getLocalizedMessage());
			e.printStackTrace(System.err);
		}


		return(positionsByChrom);
	}

}

----------------------------------------
	    				variants.put(positionKey, allele1 + "\t" + allele2);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}
		catch(Exception e)
		{
			System.err.println("ERROR: File Parsing Exception: " + e.getLocalizedMessage());
			e.printStackTrace(System.err);
		}


		return(variants);
	}
}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418763
net/sf/varscan/ProcessSomatic.java 345 366
net/sf/varscan/ReadCounts.java 352 373
----------------------------------------
	static HashMap<String, BitSet> loadTargets(String fileName, String fileType, int marginSize)
	{
		HashMap<String, BitSet> positionsByChrom = new HashMap<String, BitSet>();

		try
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

----------------------------------------
	static HashMap<String, String> loadVariants(String fileName)
	{
		HashMap<String, String> variants = new HashMap<String, String>();

		try
		{
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418764
net/sf/varscan/Comparison.java 78 94
net/sf/varscan/ProcessSomatic.java 351 366
----------------------------------------
		    int uniqueToFile2 = 0;

		    // Parse the lines in file 1 //
		    String line = "";
		    int lineCounter = 0;

		    while ((line = file1.readLine()) != null)
		    {
		    	lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

----------------------------------------
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418767
net/sf/varscan/CallMpileup.java 940 955
net/sf/varscan/CallPileup.java 324 339
----------------------------------------
	    	}
	    	// Insufficient input was provided, so print usage //
	    	else
	    	{
				 System.err.println("Please provide an input file!\n" + usage);
				 System.exit(10);
	    	}
	    }
	    catch(Exception e)
	    {
	    	System.err.println("Exception: " + e.getLocalizedMessage());
	    	e.printStackTrace(System.err);
	    	System.exit(11);
	    }
	}
}

----------------------------------------
	    	}
	    	// Insufficient input was provided, so print usage //
	    	else
	    	{
				 System.err.println("Please provide an input file!\n" + usage);
				 System.exit(10);
	    	}
	    }
	    catch(Exception e)
	    {
	    	System.err.println("Exception: " + e.getLocalizedMessage());
	    	e.printStackTrace(System.err);
	    	System.exit(11);
	    }
	}
}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418768
net/sf/varscan/CallMpileup.java 917 936
net/sf/varscan/Somatic.java 665 682
----------------------------------------
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }


	    		}

				in.close();

				System.err.println(numBases + " bases in pileup file");

----------------------------------------
	    				}
	    			}
	    			catch(Exception e)
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				numParsingExceptions++;
	    				if(numParsingExceptions >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }
	    		}

	    		// Close input/output files //
	    		in.close();
			    outSnp.close();

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418769
net/sf/varscan/CallMpileup.java 339 341
net/sf/varscan/Somatic.java 342 344
----------------------------------------
	    				if(lineContents.length > 5 && lineContents[0].length() > 0 && lineContents[1].length() > 0 && lineContents[2].length() > 0 && lineContents[3].length() > 0)
	    				{
	    					String refName = lineContents[0];

----------------------------------------
	    				if(lineContents.length > 5 && lineContents[0].length() > 0 && lineContents[1].length() > 0 && lineContents[2].length() > 0 && lineContents[3].length() > 0)
	    				{
	    					sharedPositions++;

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418770
net/sf/varscan/CallPileup.java 179 187
net/sf/varscan/Somatic.java 336 344
----------------------------------------
	    			try
	    			{
	    				String[] lineContents = line.split("\t", -1);

	    				// Verify expected pileup format //

	    				if(lineContents.length > 5 && lineContents[0].length() > 0 && lineContents[1].length() > 0 && lineContents[2].length() > 0 && lineContents[3].length() > 0)
	    				{
	    					String refName = "";

----------------------------------------
	    			try
	    			{
	    				String[] lineContents = line.split("\t", -1);

	    				// Verify expected pileup format //

	    				if(lineContents.length > 5 && lineContents[0].length() > 0 && lineContents[1].length() > 0 && lineContents[2].length() > 0 && lineContents[3].length() > 0)
	    				{
	    					sharedPositions++;

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418772
net/sf/varscan/Comparison.java 278 302
net/sf/varscan/LimitVariants.java 287 311
----------------------------------------
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}
		catch(Exception e)
		{
			System.err.println("ERROR: File Parsing Exception: " + e.getLocalizedMessage());
			e.printStackTrace(System.err);
		}


		return(positionsByChrom);
	}

}

----------------------------------------
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}
		catch(Exception e)
		{
			System.err.println("ERROR: File Parsing Exception: " + e.getLocalizedMessage());
			e.printStackTrace(System.err);
		}


		return(positionsByChrom);
	}

}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418775
net/sf/varscan/ReadCounts.java 389 412
net/sf/varscan/LimitVariants.java 287 311
----------------------------------------
	    				variants.put(positionKey, allele1 + "\t" + allele2);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}
		catch(Exception e)
		{
			System.err.println("ERROR: File Parsing Exception: " + e.getLocalizedMessage());
			e.printStackTrace(System.err);
		}


		return(variants);
	}
}

----------------------------------------
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

	    	infile.close();
		}
		catch(Exception e)
		{
			System.err.println("ERROR: File Parsing Exception: " + e.getLocalizedMessage());
			e.printStackTrace(System.err);
		}


		return(positionsByChrom);
	}

}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28418774
net/sf/varscan/Comparison.java 78 95
net/sf/varscan/ReadCounts.java 358 374
----------------------------------------
		    int uniqueToFile2 = 0;

		    // Parse the lines in file 1 //
		    String line = "";
		    int lineCounter = 0;

		    while ((line = file1.readLine()) != null)
		    {
		    	lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];
	    				int position = Integer.parseInt(lineContents[1]);

----------------------------------------
			BufferedReader infile = new BufferedReader(new FileReader(fileName));

			String line = "";
			int lineCounter = 0;

	    	while ((line = infile.readLine()) != null)
	    	{
	    		lineCounter++;

	    		String[] lineContents = line.split("\t");
	    		if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];
	    				int position = Integer.parseInt(lineContents[1]);

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28918689
net/sf/varscan/ReadCounts.java 249 266
net/sf/varscan/ReadCounts.java 250 260
----------------------------------------
			    	    				{
			    	    					try {
				    	    					int thisReads2 = Integer.parseInt(alleleContents[0]);
				    	    					int thisStrands2 = Integer.parseInt(alleleContents[1]);
				    	    					int thisAvgQual2 = Integer.parseInt(alleleContents[2]);
				    	    					int thisMapQual2 = Integer.parseInt(alleleContents[3]);
				    	    					int thisReads2plus = Integer.parseInt(alleleContents[4]);
				    	    					int thisReads2minus = Integer.parseInt(alleleContents[5]);

				    	    					String varResult = allele + ":" + thisReads2 + ":" + thisStrands2 + ":" + thisAvgQual2 + ":" + thisMapQual2 + ":" + thisReads2plus + ":" + thisReads2minus;
				    	    					outputLine += varResult + "\t";
			    	    					}
			    	    					catch(Exception e)
			    	    					{

			    	    					}

			    	    				}

----------------------------------------
			    	    					try {
				    	    					int thisReads2 = Integer.parseInt(alleleContents[0]);
				    	    					int thisStrands2 = Integer.parseInt(alleleContents[1]);
				    	    					int thisAvgQual2 = Integer.parseInt(alleleContents[2]);
				    	    					int thisMapQual2 = Integer.parseInt(alleleContents[3]);
				    	    					int thisReads2plus = Integer.parseInt(alleleContents[4]);
				    	    					int thisReads2minus = Integer.parseInt(alleleContents[5]);

				    	    					String varResult = allele + ":" + thisReads2 + ":" + thisStrands2 + ":" + thisAvgQual2 + ":" + thisMapQual2 + ":" + thisReads2plus + ":" + thisReads2minus;
				    	    					outputLine += varResult + "\t";
			    	    					}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28918690
net/sf/varscan/FilterSomatic.java 66 107
net/sf/varscan/LimitVariants.java 52 81
----------------------------------------
		{
			if(params.containsKey("output-file"))
				outFileName = params.get("output-file");

			if(params.containsKey("window-size"))
				 windowSize = Integer.parseInt(params.get("window-size"));

			if(params.containsKey("window-snps"))
				 windowSNPs = Integer.parseInt(params.get("window-snps"));

			if(params.containsKey("indel-margin"))
				 indelMargin = Integer.parseInt(params.get("indel-margin"));

			if(params.containsKey("indel-file"))
			{
				indelPositions = loadIndels(params.get("indel-file"));
			}

			if(params.containsKey("min-coverage"))
				 minCoverage = Integer.parseInt(params.get("min-coverage"));

			if(params.containsKey("min-reads2"))
				 minReads2 = Integer.parseInt(params.get("min-reads2"));

			if(params.containsKey("min-strands2"))
				 minStrands2 = Integer.parseInt(params.get("min-strands2"));

			if(params.containsKey("min-var-freq"))
				 minVarFreq = Double.parseDouble(params.get("min-var-freq"));

			if(params.containsKey("min-avg-qual"))
				 minAvgQual = Integer.parseInt(params.get("min-avg-qual"));

			if(params.containsKey("p-value"))
				 pValueThreshold = Double.parseDouble(params.get("p-value"));


			System.err.println("Window size:\t" + windowSize);
			System.err.println("Window SNPs:\t" + windowSNPs);
			System.err.println("Indel margin:\t" + indelMargin);

		}

----------------------------------------
		{
			if(params.containsKey("output-file"))
				outFileName = params.get("output-file");

			if(params.containsKey("not-file"))
				notFileName = params.get("not-file");


			if(params.containsKey("positions-file"))
			{
				targetFileName = params.get("positions-file");
				targetFileType = "positions";
			}
			else if(params.containsKey("regions-file"))
			{
				targetFileName = params.get("regions-file");
				targetFileType = "regions";
			}
			else
			{
				System.err.println("Please provide a regions file or a positions file");
				System.err.println(usage);
				return;
			}

			if(params.containsKey("margin-size"))
			{
				marginSize = Integer.parseInt(params.get("margin-size"));
			}
		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28918692
net/sf/varscan/FilterSomatic.java 525 569
net/sf/varscan/FilterSomatic.java 527 564
----------------------------------------
		{
			try
			{
				String[] snpContents = snpPosition.split("\t");
				String chrom = snpContents[0];
    			int position = Integer.parseInt(snpContents[1]);

    			// Search window size in each direction //
    			int numSNPsInWindow = 1;

    			// Check downstream window //
    			for(int thisPosition = position + 1; thisPosition <= position + windowSize; thisPosition++)
    			{
    				String thisKey = chrom + "\t" + thisPosition;
    				if(snps.containsKey(thisKey))
    				{
    					numSNPsInWindow++;
    				}
    			}

    			// If we have a cluster, mark this position as well as any downstream //

    			if(numSNPsInWindow >= windowSNPs)
    			{
    				clusterSNPs.put(snpPosition, true);

        			for(int thisPosition = position + 1; thisPosition <= position + windowSize; thisPosition++)
        			{
        				String thisKey = chrom + "\t" + thisPosition;
        				if(snps.containsKey(thisKey))
        				{
        					clusterSNPs.put(thisKey, true);
        					numClusterSNPs++;
        				}
        			}
    			}



			}
			catch(Exception e)
			{

			}
		}

----------------------------------------
			{
				String[] snpContents = snpPosition.split("\t");
				String chrom = snpContents[0];
    			int position = Integer.parseInt(snpContents[1]);

    			// Search window size in each direction //
    			int numSNPsInWindow = 1;

    			// Check downstream window //
    			for(int thisPosition = position + 1; thisPosition <= position + windowSize; thisPosition++)
    			{
    				String thisKey = chrom + "\t" + thisPosition;
    				if(snps.containsKey(thisKey))
    				{
    					numSNPsInWindow++;
    				}
    			}

    			// If we have a cluster, mark this position as well as any downstream //

    			if(numSNPsInWindow >= windowSNPs)
    			{
    				clusterSNPs.put(snpPosition, true);

        			for(int thisPosition = position + 1; thisPosition <= position + windowSize; thisPosition++)
        			{
        				String thisKey = chrom + "\t" + thisPosition;
        				if(snps.containsKey(thisKey))
        				{
        					clusterSNPs.put(thisKey, true);
        					numClusterSNPs++;
        				}
        			}
    			}



			}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28918693
net/sf/varscan/Trio.java 1010 1054
net/sf/varscan/VarScan.java 947 958
----------------------------------------
			    	    			{
			    	    				// A variant position... flag it and count the type //
			    	    				numVariantPositions++;
			    	    				variantFlag = true;

			    	    				if(variantType.equals("INDEL"))
			    	    				{
			    	    					numIndelPositions++;
			    	    				}
			    	    				else
			    	    				{
			    	    					numSNPpositions++;
			    	    				}

			    	    				// Also count pass/fail filter statuses //

			    	    				if(strandFilterStatus.contains("Fail"))
			    	    				{
			    	    					numFailStrandFilter++;
			    	    				}
			    	    				else if(trioStatus.equals("MIE"))
			    	    				{
			    	    					numFailMendelFilter++;
			    	    				}
			    	    				else
			    	    				{
			    	    					numVariantsReported++;
			    	    					if(trioStatus.equals("DeNovo"))
			    	    						numVariantsReportedDeNovo++;

				    	    				if(variantType.equals("INDEL"))
				    	    				{
				    	    					numIndelsReported++;
				    	    					if(trioStatus.equals("DeNovo"))
				    	    						numIndelsReportedDeNovo++;
				    	    				}
				    	    				else
				    	    				{
				    	    					numSNPsReported++;
				    	    					if(trioStatus.equals("DeNovo"))
				    	    						numSNPsReportedDeNovo++;
				    	    				}
			    	    				}

			    	    			}

----------------------------------------
			{
				if(readBase.equals(".") || readBase.equals(","))
				{
					// This is the reference base that precedes an indel. Don't advance quality //
				}
				else
				{
					// Ignore characters like * which indicates a pad //
					j++;
				}

			}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28918694
net/sf/varscan/LimitVariants.java 232 297
net/sf/varscan/Coverage.java 155 225
----------------------------------------
	    	{
	    		lineCounter++;
	    		String[] lineContents = line.split("\t");

	    		if(line.substring(0, 1).equals("#"))
	    		{
	    			// Ignore VCF headers //
	    		}
	    		else if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

----------------------------------------
	    			{
	    				String[] lineContents = line.split("\t");

	    				// Verify expected pileup format //

	    				if(lineContents.length > 5 && lineContents[0].length() > 0 && lineContents[1].length() > 0 && lineContents[2].length() > 0 && lineContents[3].length() > 0)
	    				{
	    					String refName = lineContents[0];
		    	        	int position = Integer.parseInt(lineContents[1]);

		    				// Declare a BitSet //
		    				BitSet refPositions;

		    				boolean inTarget = false;

		    				if(!params.containsKey("regions-file"))
		    				{
		    					// If no regions file provided, report on all positions //
		    					inTarget = true;
		    				}
		    				// Get the position BitSet for this chromosome//
		    				else if(targetHash.containsKey(refName))
		    				{
		    					refPositions = targetHash.get(refName);

		    					// Check to see if position set //
		    					if(refPositions.get(position))
		    					{
		    						inTarget = true;
		    					}
		    				}

		    				if(inTarget)
		    				{
		    					basesOnTarget++;

		    					try {
		    						// Parse out the depth and base qualities //
				    	        	int readDepth = Integer.parseInt(lineContents[3]);
				    	        	String readQualities = lineContents[5];

				    	        	String mapQualities = "";
				    	        	if(lineContents.length > 6)			// Get Map Qualities if available //
				    	        		mapQualities = lineContents[6];

				    	        	int qualDepth = VarScan.qualityDepth(readQualities, minBaseQual);

				    	        	for(int thisDepth = 0; thisDepth <= qualDepth; thisDepth++)
				    	        	{
				    	        		positionsByDepth[thisDepth]++;
				    	        	}
		    					}
		    					catch (Exception e)
		    					{

		    					}

		    				}
		    				else
		    				{
		    					basesOffTarget++;
		    				}


	    				}
	    				else
	    				{
	    					System.err.println("Error: Invalid format for pileup at line " + lineCounter + ":" + line + "\n");
	    					return;
	    				}
	    			}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28918697
net/sf/varscan/Coverage.java 349 399
net/sf/varscan/CopyCaller.java 223 278
----------------------------------------
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
    						numRegions++;

	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						if(!refPositions.get(position))
	    						{
	    							numBases++;
	    							refPositions.set(position, true);
	    						}
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}

----------------------------------------
	    				{
	    					String refName = lineContents[0];

	    					// Print the header line //
	    					if(refName.equals("chrom"))
	    					{

	    					}
	    					else if(!refName.equals("chrom"))
	    					{
	    						stats.put("numRegions", (stats.get("numRegions") + 1));

		    					long regionStart = Long.parseLong(lineContents[1]);
		    					long regionStop = Long.parseLong(lineContents[2]);
		    					long numPositions = Long.parseLong(lineContents[3]);

		    					// Fix locale-parsing issues //
		    					float normalDepth = Float.parseFloat(lineContents[4].replace(',', '.'));
		    					float tumorDepth = Float.parseFloat(lineContents[5].replace(',', '.'));
			    	        	double logratio = Double.parseDouble(lineContents[6].replace(',', '.'));

			    	        	if(recenterBaseline != 0)
			    	        		logratio = logratio - recenterBaseline;

			    	        	if(lineContents.length >= 8)
			    	        	{
			    	        		// Apply coverage threshold //
			    	        		if(normalDepth >= minCoverage && tumorDepth >= minTumorCoverage)
			    	        		{
				    	        		float gcContent = Float.parseFloat(lineContents[7].replace(',', '.'));
				    	        		int gcBin = (int) gcContent;
				    	        		if(gcBin >= 0 && gcBin <= 100)
				    	        		{
				    	        			gcLogSum[gcBin] += (float) logratio;
				    	        			gcLogNum[gcBin]++;
				    	        		}
			    	        		}

			    	        	}
			    	        	else
			    	        	{
			    	        		// No GC information.. warn if we haven't already //
			    	        		if(!gcWarned)
			    	        		{
			    	        			System.err.println("Warning: Older VarScan copynumber output (without GC content column) detected, so no GC adjustment will be performed");
			    	        			gcWarned = true;
			    	        		}
			    	        	}


	    					}
	    					else
	    					{
	    						// Don't process the header line //
	    					}
	    				}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28918698
net/sf/varscan/FpFilter.java 363 389
net/sf/varscan/Copynumber.java 676 708
----------------------------------------
        	    					{
        	    						ref = lineContents[2];
        	    						String cns = lineContents[3];
        	    						if(cns.length() > 1)
        	    						{
        	    							isIndel = true;
        	    							// CONVERT INDEL //
        	    							if(cns.contains("/"))
        	    							{
            	    							String[] indelContents = cns.split("/");
            	    							if(indelContents.length > 1)
            	    								alt = indelContents[1];
        	    							}
        	    							else
        	    							{
        	    								alt = cns;
        	    							}

        	    						}
        	    						else
        	    						{
        	    							// CONVERT SNV //
            	    						alt = VarScan.getVarAllele(ref, cns);

        	    						}

        	    					}

----------------------------------------
		    		{
		    			String[] normalContents = lineNormal.split("\t");
				    	if(normalContents.length > 1)
				    	{
					    	chromNormal = normalContents[0];
					    	posNormal = Integer.parseInt(normalContents[1]);

					    	// If still less than tumor position, look for homozygous del //
					    	if(posNormal < posTumor)
					    	{
					    		int pileupDepthNormal = 0;
					    		String normalQualities = "";

			    				// Pileup Files have 6-7 columns //
		    					if(normalContents.length <= 7)
		    					{
		    						pileupDepthNormal = Integer.parseInt(normalContents[3]);
		    						normalQualities = normalContents[5];
		    					}
		    					// Pileup lines in CNS files have 10-11 columns
		    					else if (normalContents.length >= 10 && normalContents.length <= 11)
		    					{
		    						pileupDepthNormal = Integer.parseInt(normalContents[7]);
		    						normalQualities = normalContents[9];
		    					}

					    	}
					    	else
					    	{

					    	}
				    	}
		    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28918729
net/sf/varscan/Somatic.java 1404 1419
net/sf/varscan/Copynumber.java 676 708
----------------------------------------
		    		{
		    			if((lineTumor = tumor.readLine()) != null)
		    			{
			    			tumorContents = lineTumor.split("\t");

					    	if(tumorContents.length > 1)
					    	{
						    	chromTumor = tumorContents[0];
						    	posTumor = Integer.parseInt(tumorContents[1]);
					    	}
		    			}
		    			else
		    			{
		    				flagEOF = true;
		    			}
		    		}

----------------------------------------
		    		{
		    			String[] normalContents = lineNormal.split("\t");
				    	if(normalContents.length > 1)
				    	{
					    	chromNormal = normalContents[0];
					    	posNormal = Integer.parseInt(normalContents[1]);

					    	// If still less than tumor position, look for homozygous del //
					    	if(posNormal < posTumor)
					    	{
					    		int pileupDepthNormal = 0;
					    		String normalQualities = "";

			    				// Pileup Files have 6-7 columns //
		    					if(normalContents.length <= 7)
		    					{
		    						pileupDepthNormal = Integer.parseInt(normalContents[3]);
		    						normalQualities = normalContents[5];
		    					}
		    					// Pileup lines in CNS files have 10-11 columns
		    					else if (normalContents.length >= 10 && normalContents.length <= 11)
		    					{
		    						pileupDepthNormal = Integer.parseInt(normalContents[7]);
		    						normalQualities = normalContents[9];
		    					}

					    	}
					    	else
					    	{

					    	}
				    	}
		    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28918728
net/sf/varscan/Copynumber.java 919 934
net/sf/varscan/Copynumber.java 676 708
----------------------------------------
		    		{
		    			if((lineTumor = tumor.readLine()) != null)
		    			{
			    			tumorContents = lineTumor.split("\t");

					    	if(tumorContents.length > 1)
					    	{
						    	chromTumor = tumorContents[0];
						    	posTumor = Integer.parseInt(tumorContents[1]);
					    	}
		    			}
		    			else
		    			{
		    				flagEOF = true;
		    			}
		    		}

----------------------------------------
		    		{
		    			String[] normalContents = lineNormal.split("\t");
				    	if(normalContents.length > 1)
				    	{
					    	chromNormal = normalContents[0];
					    	posNormal = Integer.parseInt(normalContents[1]);

					    	// If still less than tumor position, look for homozygous del //
					    	if(posNormal < posTumor)
					    	{
					    		int pileupDepthNormal = 0;
					    		String normalQualities = "";

			    				// Pileup Files have 6-7 columns //
		    					if(normalContents.length <= 7)
		    					{
		    						pileupDepthNormal = Integer.parseInt(normalContents[3]);
		    						normalQualities = normalContents[5];
		    					}
		    					// Pileup lines in CNS files have 10-11 columns
		    					else if (normalContents.length >= 10 && normalContents.length <= 11)
		    					{
		    						pileupDepthNormal = Integer.parseInt(normalContents[7]);
		    						normalQualities = normalContents[9];
		    					}

					    	}
					    	else
					    	{

					    	}
				    	}
		    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28918701
net/sf/varscan/FpFilter.java 792 871
net/sf/varscan/FpFilter.java 803 863
----------------------------------------
	{
    	HashMap<String, String> readcounts = new HashMap<String, String>();

	    try
	    {
	    	// Declare file-parsing variables //

	    	String line;

    		File infile = new File(filename);
    		if(infile.exists())
    		{
    			BufferedReader in = new BufferedReader(new FileReader(infile));

    			if(in.ready())
    			{
    				while ((line = in.readLine()) != null)
    				{
    					String[] lineContents = line.split("\t");
						try {
							String chrom = lineContents[0];
	    					String position = lineContents[1];
//	    					String snvKey = chrom + "\t" + position;

	    					// Start resultLine as depth //


	    					for(int colCounter = 4; colCounter < lineContents.length; colCounter++)
	    					{
	    						String[] alleleContents = lineContents[colCounter].split(":");
	    						String thisAllele = alleleContents[0];
	    						int thisReads = Integer.parseInt(alleleContents[1]);

	    						if(thisAllele.equals("N") || thisAllele.equals("="))
	    						{
	    							// Skip non-informative alleles //
	    						}
	    						else if(thisReads == 0)
	    						{
	    							// Skip empty results //
	    						}
	    						else
	    						{
		    						String rcLine = lineContents[3];
		    						rcLine = rcLine + "\t" + lineContents[colCounter];
		    						// Save the readcount result line //
		    						String snvKey = chrom + "\t" + position + "\t" + thisAllele;
			    					readcounts.put(snvKey, rcLine);
	    						}


	    					}


						}
						catch (Exception e)
						{
							// If we encounter an issue, print a warning //
							System.err.println("Warning: Exception thrown while loading bam-readcount: " + e.getMessage());
							System.err.println("Attempting to continue, but please double-check file format and completeness");
						}


    				}
    			}
    			else
    			{
    				System.err.println("Unable to open SNVs file for reading");
    			}

    			in.close();
    		}
	    }
	    catch(Exception e)
	    {
	    	System.err.println("Error Parsing SNV File: " + e.getLocalizedMessage());
	    }

	    return(readcounts);
	}

----------------------------------------
    		{
    			BufferedReader in = new BufferedReader(new FileReader(infile));

    			if(in.ready())
    			{
    				while ((line = in.readLine()) != null)
    				{
    					String[] lineContents = line.split("\t");
						try {
							String chrom = lineContents[0];
	    					String position = lineContents[1];
//	    					String snvKey = chrom + "\t" + position;

	    					// Start resultLine as depth //


	    					for(int colCounter = 4; colCounter < lineContents.length; colCounter++)
	    					{
	    						String[] alleleContents = lineContents[colCounter].split(":");
	    						String thisAllele = alleleContents[0];
	    						int thisReads = Integer.parseInt(alleleContents[1]);

	    						if(thisAllele.equals("N") || thisAllele.equals("="))
	    						{
	    							// Skip non-informative alleles //
	    						}
	    						else if(thisReads == 0)
	    						{
	    							// Skip empty results //
	    						}
	    						else
	    						{
		    						String rcLine = lineContents[3];
		    						rcLine = rcLine + "\t" + lineContents[colCounter];
		    						// Save the readcount result line //
		    						String snvKey = chrom + "\t" + position + "\t" + thisAllele;
			    					readcounts.put(snvKey, rcLine);
	    						}


	    					}


						}
						catch (Exception e)
						{
							// If we encounter an issue, print a warning //
							System.err.println("Warning: Exception thrown while loading bam-readcount: " + e.getMessage());
							System.err.println("Attempting to continue, but please double-check file format and completeness");
						}


    				}
    			}
    			else
    			{
    				System.err.println("Unable to open SNVs file for reading");
    			}

    			in.close();
    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28918702
net/sf/varscan/FpFilter.java 834 840
net/sf/varscan/CopyCaller.java 479 490
----------------------------------------
	    						{
		    						String rcLine = lineContents[3];
		    						rcLine = rcLine + "\t" + lineContents[colCounter];
		    						// Save the readcount result line //
		    						String snvKey = chrom + "\t" + position + "\t" + thisAllele;
			    					readcounts.put(snvKey, rcLine);
	    						}

----------------------------------------
			    	        	{
			    	        		// Output candidate homozygous deletion //
		    	        			String outLine = refName + "\t" + regionStart + "\t" + regionStop + "\t" + numPositions + "\t";
		    	        			outLine += normalDepth + "\t" + tumorDepth + "\t" + threeDigits.format(adjustedRatio) + "\t" + gcContent + "\thomozygous_deletion\t" + logratio;
		    	        			stats.put("numHomDel", (stats.get("numHomDel") + 1));
	    	        				baseCounts.put("numHomDel", (baseCounts.get("numHomDel") + regionSize));
	    	        				if(params.containsKey("output-homdel-file"))
	    	        				{
	    	        					outHomdel.println(outLine);
	    	        				}

			    	        	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28918703
net/sf/varscan/LimitVariants.java 52 81
net/sf/varscan/VarScan.java 485 539
----------------------------------------
		{
			if(params.containsKey("output-file"))
				outFileName = params.get("output-file");

			if(params.containsKey("not-file"))
				notFileName = params.get("not-file");


			if(params.containsKey("positions-file"))
			{
				targetFileName = params.get("positions-file");
				targetFileType = "positions";
			}
			else if(params.containsKey("regions-file"))
			{
				targetFileName = params.get("regions-file");
				targetFileType = "regions";
			}
			else
			{
				System.err.println("Please provide a regions file or a positions file");
				System.err.println(usage);
				return;
			}

			if(params.containsKey("margin-size"))
			{
				marginSize = Integer.parseInt(params.get("margin-size"));
			}
		}

----------------------------------------
	    {
	    	// Declare file-parsing variables //

	    	String line;

	    	// Check for file on command line //

	    	if(args.length > 1 && !args[1].startsWith("-"))
	    	{
	    		File infile = new File(args[1]);
	    		if(infile.exists())
	    		{
	    			// Parse the infile //
	    			System.err.println("Reading input from " + args[1]);
	    			in = new BufferedReader(new FileReader(args[1]));
	    		}
	    		else
	    		{
//    				System.err.println("File not found: " + args[1] + "\n");
//    				System.exit(10);
	    		}
	    	}

	    	// If no file from command line was parsed, try for piped input //

	    	if(in == null)
	    	{
		    	// Check the input stream //
		    	InputStreamReader instream = new InputStreamReader(System.in);
		    	Thread.sleep(1000);

		    	int num_naps = 0;

	    		while(!instream.ready())
	    		{
	    			System.err.println("Input stream not ready, waiting for 5 seconds...");
	    			Thread.sleep(5000);
	    			num_naps++;

	    			if(num_naps >= 100)
	    			{
	    				System.err.println("ERROR: Gave up waiting after 500 seconds...\n");
	    				System.exit(10);
	    			}
	    		}

		    	// If we have piped input, proceed with it //

		    	if(instream.ready())
		    	{
		    		System.err.println("Reading input from STDIN");
			    	in = new BufferedReader(instream);
		    	}
	    	}
	    }

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28918705
net/sf/varscan/Copynumber.java 68 93
net/sf/varscan/VarScan.java 1226 1245
----------------------------------------
		{
			if(params.containsKey("min-coverage"))
			{
				 minCoverage = Integer.parseInt(params.get("min-coverage"));
			}

			if(params.containsKey("min-base-qual"))
				 minBaseQual = Integer.parseInt(params.get("min-base-qual"));

			if(params.containsKey("min-segment-size"))
				 minSegmentSize = Integer.parseInt(params.get("min-segment-size"));

			if(params.containsKey("max-segment-size"))
				 maxSegmentSize = Integer.parseInt(params.get("max-segment-size"));

			if(params.containsKey("p-value"))
				 pValueThreshold = Double.parseDouble(params.get("p-value"));

			if(params.containsKey("data-ratio"))
				 dataRatio = Double.parseDouble(params.get("data-ratio"));

			System.err.println("Min coverage:\t" + minCoverage);
			System.err.println("Min avg qual:\t" + minBaseQual);
			System.err.println("P-value thresh:\t" + pValueThreshold);

		}

----------------------------------------
						{
//							System.err.println(allele + " passed with " + thisReads2);
							if(allele.contains("INS") || allele.contains("DEL"))
							{
								varAllele = getShortIndel(allele);
							}
							else
							{
								varAllele = allele;
							}

							reads2 = thisReads2;
							strands2 = thisStrands2;
							avgQual2 = thisAvgQual2;
							avgMap2 = thisAvgMap2;
							reads2plus = thisReads2plus;
							reads2minus = thisReads2minus;
							varFreq = thisVarFreq * 100;
							pValue = thisPvalue;
						}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28918706
net/sf/varscan/Copynumber.java 491 516
net/sf/varscan/VarScan.java 1226 1245
----------------------------------------
		{
			if(params.containsKey("min-coverage"))
			{
				 minCoverage = Integer.parseInt(params.get("min-coverage"));
			}

			if(params.containsKey("min-base-qual"))
				 minBaseQual = Integer.parseInt(params.get("min-base-qual"));

			if(params.containsKey("min-segment-size"))
				 minSegmentSize = Integer.parseInt(params.get("min-segment-size"));

			if(params.containsKey("max-segment-size"))
				 maxSegmentSize = Integer.parseInt(params.get("max-segment-size"));

			if(params.containsKey("p-value"))
				 pValueThreshold = Double.parseDouble(params.get("p-value"));

			if(params.containsKey("data-ratio"))
				 dataRatio = Double.parseDouble(params.get("data-ratio"));

			System.err.println("Min coverage:\t" + minCoverage);
			System.err.println("Min avg qual:\t" + minBaseQual);
			System.err.println("P-value thresh:\t" + pValueThreshold);

		}

----------------------------------------
						{
//							System.err.println(allele + " passed with " + thisReads2);
							if(allele.contains("INS") || allele.contains("DEL"))
							{
								varAllele = getShortIndel(allele);
							}
							else
							{
								varAllele = allele;
							}

							reads2 = thisReads2;
							strands2 = thisStrands2;
							avgQual2 = thisAvgQual2;
							avgMap2 = thisAvgMap2;
							reads2plus = thisReads2plus;
							reads2minus = thisReads2minus;
							varFreq = thisVarFreq * 100;
							pValue = thisPvalue;
						}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28918707
net/sf/varscan/VarScan.java 1671 1685
net/sf/varscan/VarScan.java 1669 1691
----------------------------------------
			 {
				 String[] gtContents = gt.split("-");
				 String indel_type = gtContents[0];
				 String indel_size = gtContents[1];
				 String indel_bases = gtContents[2];

				 if(indel_type.contains("INS"))
				 {
					 return("+" + indel_bases);
				 }
				 else
				 {
					 return("-" + indel_bases);
				 }
			 }

----------------------------------------
		 {
			 try
			 {
				 String[] gtContents = gt.split("-");
				 String indel_type = gtContents[0];
				 String indel_size = gtContents[1];
				 String indel_bases = gtContents[2];

				 if(indel_type.contains("INS"))
				 {
					 return("+" + indel_bases);
				 }
				 else
				 {
					 return("-" + indel_bases);
				 }
			 }
			 catch(Exception e)
			 {
				 System.err.println("Warning: error generating consensus from " + gt);
			 }

		 }

----------------------------------------
