$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834328
net/sf/varscan/VarScan.java 718 728
net/sf/varscan/VarScan.java 730 740
----------------------------------------
					{
						// Plus strand //
						if(readCountsPlus.containsKey(readBase))
						{
							readCountsPlus.put(readBase, (readCountsPlus.get(readBase) + 1));
						}
						else
						{
							readCountsPlus.put(readBase, 1);
						}
					}

----------------------------------------
					{
						// Minus Strand //
						if(readCountsMinus.containsKey(readBase))
						{
							readCountsMinus.put(readBase, (readCountsMinus.get(readBase) + 1));
						}
						else
						{
							readCountsMinus.put(readBase, 1);
						}
					}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834392
net/sf/varscan/Somatic.java 256 265
net/sf/varscan/Coverage.java 112 121
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 10)
			    	{
			    		System.err.println("Input file was not ready after 10 5-second cycles!");
			    		return;
			    	}
		    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834391
net/sf/varscan/CallMpileup.java 234 243
net/sf/varscan/Coverage.java 112 121
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 10)
			    	{
			    		System.err.println("Input file was not ready after 10 5-second cycles!");
			    		return;
			    	}
		    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834393
net/sf/varscan/ProcessSomatic.java 80 89
net/sf/varscan/Coverage.java 112 121
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 10)
			    	{
			    		System.err.println("Input file was not ready after 10 5-second cycles!");
			    		return;
			    	}
		    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834394
net/sf/varscan/Somatic.java 965 974
net/sf/varscan/Coverage.java 112 121
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file(s) were not ready for parsing after 100 5-second cycles! Pileup output may be invalid or too slow");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 10)
			    	{
			    		System.err.println("Input file was not ready after 10 5-second cycles!");
			    		return;
			    	}
		    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834329
net/sf/varscan/CallPileup.java 142 151
net/sf/varscan/Coverage.java 112 121
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 10)
			    	{
			    		System.err.println("Input file was not ready after 10 5-second cycles!");
			    		return;
			    	}
		    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834395
net/sf/varscan/ReadCounts.java 126 134
net/sf/varscan/Coverage.java 112 121
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;
			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
	    		}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 10)
			    	{
			    		System.err.println("Input file was not ready after 10 5-second cycles!");
			    		return;
			    	}
		    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834334
net/sf/varscan/FishersExact.java 105 115
net/sf/varscan/FishersExact.java 95 104
----------------------------------------
        if ((a * d) < (b * c)) {
            if (DEBUG) {System.out.println("doing L-tail: a=" + a + " b=" + b + " c=" + c + " d=" + d);}
            min = (a < d) ? a : d;
            for (i = 0; i < min; i++) {
                if (DEBUG) {System.out.print("doing round " + i);}
                double pTemp = getP(--a, ++b, ++c, --d);
                if (DEBUG) {System.out.print("\tpTemp = " + pTemp);}
                p += pTemp;
                if (DEBUG) {System.out.println("\ta=" + a + " b=" + b + " c=" + c + " d=" + d);}
            }
        }

----------------------------------------
        if ((a * d) >= (b * c)) {
            if (DEBUG) {System.out.println("doing R-tail: a=" + a + " b=" + b + " c=" + c + " d=" + d);}
            min = (c < b) ? c : b;
            for (i = 0; i < min; i++) {
                if (DEBUG) {System.out.print("doing round " + i);}
                p += getP(++a, --b, --c, ++d);
                if (DEBUG) {System.out.println("\ta=" + a + " b=" + b + " c=" + c + " d=" + d);}
            }
            System.out.println("");
        }

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834335
net/sf/varscan/VarScan.java 1274 1319
net/sf/varscan/VarScan.java 1321 1347
----------------------------------------
								{
									reads2 = thisReads2;
									strands2 = thisStrands2;
									avgQual2 = thisAvgQual2;
									avgMap2 = thisAvgMap2;
									reads2plus = thisReads2plus;
									reads2minus = thisReads2minus;
									pValue = thisPvalue;

									// Convert to consensus-like genotype //

									String genotype = "";
									if(thisVarFreq >= (minFreqForHom * 100))
									{
										genotype = allele + allele;
										if(thisVarType.equals("INDEL"))
											genotype = allele + "/" + allele;
									}
									else
									{
										genotype = refBase + allele;
										if(thisVarType.equals("INDEL"))
											genotype = "*/" + allele;
									}

									// Only report the desired variant type //

									if(thisVarType.equals(callType))
									{
										// Report the variant regardless //
										if(callResult.length() > 0)
											callResult += "\n";

										if(thisReads1 < 0)
											thisReads1 = 0;

										if(reads2 < 0)
											reads2 = 0;

										//callResult += allele + "\t" + reads1 + "\t" + reads2 + "\t" + df.format(thisVarFreq) + "%\t" + strands1 + "\t" + strands2 + "\t" + avgQual1 + "\t" + avgQual2 + "\t" + pValue;
										callResult += genotypeToCode(genotype) + "\t" + thisReads1 + "\t" + reads2 + "\t" + df.format(thisVarFreq) + "%\t" + strands1 + "\t" + strands2 + "\t" + avgQual1 + "\t" + avgQual2 + "\t" + pValue;
										callResult += "\t" + avgMap1 + "\t" + avgMap2;
										callResult += "\t" + reads1plus + "\t" + reads1minus + "\t" + reads2plus + "\t" + reads2minus + "\t" + varAllele;
									}

								}

----------------------------------------
								{
									reads2 = thisReads2;
									strands2 = thisStrands2;
									avgQual2 = thisAvgQual2;
									avgMap2 = thisAvgMap2;
									reads2plus = thisReads2plus;
									reads2minus = thisReads2minus;
									pValue = thisPvalue;

									String genotype = "";
									if(thisVarFreq >= (minFreqForHom * 100))
									{
										genotype = allele + allele;
										if(thisVarType.equals("INDEL"))
											genotype = allele + "/" + allele;
									}
									else
									{
										genotype = refBase + allele;
										if(thisVarType.equals("INDEL"))
											genotype = "*/" + allele;
									}

									callResult = genotypeToCode(genotype) + "\t" + thisReads1 + "\t" + reads2 + "\t" + df.format(thisVarFreq) + "%\t" + strands1 + "\t" + strands2 + "\t" + avgQual1 + "\t" + avgQual2 + "\t" + pValue;
									callResult += "\t" + avgMap1 + "\t" + avgMap2;
									callResult += "\t" + reads1plus + "\t" + reads1minus + "\t" + reads2plus + "\t" + reads2minus + "\t" + varAllele;
								}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834336
net/sf/varscan/CallMpileup.java 686 729
net/sf/varscan/VarScan.java 1409 1454
----------------------------------------
	    					{
    	    					double refStrandPlus = 0.50;
    	    					double varStrandPlus = 0.50;

    	    					// Calculate strandedness for variant allele //

    	    					if((allReads2plus + allReads2minus) > 0)
    	    						varStrandPlus = (double) allReads2plus / (double) (allReads2plus + allReads2minus);

    	    					// To save time, only calculate p-value if var strandedness is biased //

    	    					if(varStrandPlus < 0.10 || varStrandPlus > 0.90)
    	    					{
    	    						// Calculate strandedness for reference allele if we have 2+ reads //

        	    					if((allReads1plus + allReads1minus) > 1)
        	    					{
        	    						refStrandPlus = (double) allReads1plus / (double) (allReads1plus + allReads1minus);
        	    						strandPvalue = VarScan.getSignificance(allReads1plus, allReads1minus, allReads2plus, allReads2minus);
        	    					}
        	    					// Otherwise, only homozygous-variant reads seen, so compare to a 50/50 distribution //
    	    						else
    	    						{
    	    							// Compare to expected 50/50 distribution //
    	    							int testReads1plus = (int) (allReads2plus + allReads2minus) / 2;
    	    							int testReads1minus = (allReads2plus + allReads2minus) - testReads1plus;
    	    							strandPvalue = VarScan.getSignificance(testReads1plus, testReads1minus, allReads2plus, allReads2minus);
    	    						}

        	    					strandFilterStatus = "Pass:" + varStrandPlus + ":" + allReads1plus + ":" + allReads1minus + ":" + allReads2plus + ":" + allReads2minus + ":" + pvalueFormat.format(strandPvalue);

    	    						// If ref allele had good strandedness, and var allele did not, this may be a failure //
    	    						if(refStrandPlus >= 0.10 && refStrandPlus <= 0.90 && !(varStrandPlus >= 0.10 && varStrandPlus <= 0.90))
    	    						{
    	    							if(strandPvalue < strandPvalueThreshold)
    	    	    					{
    	    	    						strandFilterStatus = "Fail:" + allReads1plus + ":" + allReads1minus + ":" + allReads2plus + ":" + allReads2minus + ":" + pvalueFormat.format(strandPvalue);
    	    	    						numFailStrandFilter++;
    	    	    						failedStrandFilter = true;
    	    	    					}
    	    						}
    	    					}

	    					}

----------------------------------------
	{
		DecimalFormat pvalueFormat = new DecimalFormat("0.####E0");
		String strandFilterStatus = "Pass:" + reads1plus + ":" + reads1minus + ":" + reads2plus + ":" + reads2minus + ":" + 1;
		double refStrandPlus = 0.50;
		double varStrandPlus = 0.50;
		double strandPvalue = 1.00;

		// Calculate strandedness for variant allele //

		if((reads2plus + reads2minus) > 0)
			varStrandPlus = (double) reads2plus / (double) (reads2plus + reads2minus);

		// To save time, only calculate p-value if var strandedness is biased //

		if(varStrandPlus < 0.10 || varStrandPlus > 0.90)
		{
			// Calculate strandedness for reference allele if we have 2+ reads //

			if((reads1plus + reads1minus) > 1)
			{
				refStrandPlus = (double) reads1plus / (double) (reads1plus + reads1minus);
				strandPvalue = VarScan.getSignificance(reads1plus, reads1minus, reads2plus, reads2minus);
			}
			// Otherwise, only homozygous-variant reads seen, so compare to a 50/50 distribution //
			else
			{
				// Compare to expected 50/50 distribution //
				int testReads1plus = (int) (reads2plus + reads2minus) / 2;
				int testReads1minus = (reads2plus + reads2minus) - testReads1plus;
				strandPvalue = VarScan.getSignificance(testReads1plus, testReads1minus, reads2plus, reads2minus);
			}

			strandFilterStatus = "Pass:" + varStrandPlus + ":" + reads1plus + ":" + reads1minus + ":" + reads2plus + ":" + reads2minus + ":" + pvalueFormat.format(strandPvalue);

			// If ref allele had good strandedness, and var allele did not, this may be a failure //
			if(refStrandPlus >= 0.10 && refStrandPlus <= 0.90 && !(varStrandPlus >= 0.10 && varStrandPlus <= 0.90))
			{
				if(strandPvalue < strandPvalueThreshold)
				{
					strandFilterStatus = "Fail:" + reads1plus + ":" + reads1minus + ":" + reads2plus + ":" + reads2minus + ":" + pvalueFormat.format(strandPvalue);
				}
			}
		}

		return(strandFilterStatus);
	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28918691
net/sf/varscan/FilterSomatic.java 253 261
net/sf/varscan/VarScan.java 1168 1181
----------------------------------------
	    					{
			    				normalReads1 = Integer.parseInt(lineContents[4]);
			    				normalReads2 = Integer.parseInt(lineContents[5]);
			    				tumorReads1 = Integer.parseInt(lineContents[8]);
			    				tumorReads2 = Integer.parseInt(lineContents[9]);

			    				somaticStatus = lineContents[12];
			    				somaticPvalue = Double.parseDouble(lineContents[14]);
	    					}

----------------------------------------
					try {
						thisReads2 = Integer.parseInt(alleleContents[0]);
						thisStrands2 = Integer.parseInt(alleleContents[1]);
						thisAvgQual2 = Integer.parseInt(alleleContents[2]);
						thisAvgMap2 = Integer.parseInt(alleleContents[3]);
						thisReads2plus = Integer.parseInt(alleleContents[4]);
						thisReads2minus = Integer.parseInt(alleleContents[5]);
						// If this is an indel, make note of it //

						if(allele.contains("INS") || allele.contains("DEL"))
						{
							readsWithIndels += thisReads2;
						}
					}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
28918704
net/sf/varscan/ProcessSomatic.java 232 240
net/sf/varscan/VarScan.java 1168 1181
----------------------------------------
	    					{
			    				normalReads1 = Integer.parseInt(lineContents[4]);
			    				normalReads2 = Integer.parseInt(lineContents[5]);
			    				tumorReads1 = Integer.parseInt(lineContents[8]);
			    				tumorReads2 = Integer.parseInt(lineContents[9]);

			    				somaticStatus = lineContents[12];
			    				somaticPvalue = Double.parseDouble(lineContents[14]);
	    					}

----------------------------------------
					try {
						thisReads2 = Integer.parseInt(alleleContents[0]);
						thisStrands2 = Integer.parseInt(alleleContents[1]);
						thisAvgQual2 = Integer.parseInt(alleleContents[2]);
						thisAvgMap2 = Integer.parseInt(alleleContents[3]);
						thisReads2plus = Integer.parseInt(alleleContents[4]);
						thisReads2minus = Integer.parseInt(alleleContents[5]);
						// If this is an indel, make note of it //

						if(allele.contains("INS") || allele.contains("DEL"))
						{
							readsWithIndels += thisReads2;
						}
					}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834338
net/sf/varscan/VarScan.java 1110 1121
net/sf/varscan/VarScan.java 1168 1181
----------------------------------------
				{
					String[] refBaseContents = readCounts.get(refBase).split("\t");
					reads1 = Integer.parseInt(refBaseContents[0]);
					strands1 = Integer.parseInt(refBaseContents[1]);
					avgQual1 = Integer.parseInt(refBaseContents[2]);
					avgMap1 = Integer.parseInt(refBaseContents[3]);
					reads1plus = Integer.parseInt(refBaseContents[4]);
					reads1minus = Integer.parseInt(refBaseContents[5]);

					if(refBaseContents.length > 6)
						reads1indel = Integer.parseInt(refBaseContents[6]);
				}

----------------------------------------
					try {
						thisReads2 = Integer.parseInt(alleleContents[0]);
						thisStrands2 = Integer.parseInt(alleleContents[1]);
						thisAvgQual2 = Integer.parseInt(alleleContents[2]);
						thisAvgMap2 = Integer.parseInt(alleleContents[3]);
						thisReads2plus = Integer.parseInt(alleleContents[4]);
						thisReads2minus = Integer.parseInt(alleleContents[5]);
						// If this is an indel, make note of it //

						if(allele.contains("INS") || allele.contains("DEL"))
						{
							readsWithIndels += thisReads2;
						}
					}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834400
net/sf/varscan/CallMpileup.java 234 243
net/sf/varscan/VarScan.java 519 529
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
	    		{
	    			System.err.println("Input stream not ready, waiting for 5 seconds...");
	    			Thread.sleep(5000);
	    			num_naps++;

	    			if(num_naps >= 100)
	    			{
	    				System.err.println("ERROR: Gave up waiting after 500 seconds...\n");
	    				System.exit(10);
	    			}
	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834403
net/sf/varscan/Somatic.java 965 974
net/sf/varscan/VarScan.java 519 529
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file(s) were not ready for parsing after 100 5-second cycles! Pileup output may be invalid or too slow");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
	    		{
	    			System.err.println("Input stream not ready, waiting for 5 seconds...");
	    			Thread.sleep(5000);
	    			num_naps++;

	    			if(num_naps >= 100)
	    			{
	    				System.err.println("ERROR: Gave up waiting after 500 seconds...\n");
	    				System.exit(10);
	    			}
	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834402
net/sf/varscan/ProcessSomatic.java 80 89
net/sf/varscan/VarScan.java 519 529
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
	    		{
	    			System.err.println("Input stream not ready, waiting for 5 seconds...");
	    			Thread.sleep(5000);
	    			num_naps++;

	    			if(num_naps >= 100)
	    			{
	    				System.err.println("ERROR: Gave up waiting after 500 seconds...\n");
	    				System.exit(10);
	    			}
	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834401
net/sf/varscan/Somatic.java 256 265
net/sf/varscan/VarScan.java 519 529
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
	    		{
	    			System.err.println("Input stream not ready, waiting for 5 seconds...");
	    			Thread.sleep(5000);
	    			num_naps++;

	    			if(num_naps >= 100)
	    			{
	    				System.err.println("ERROR: Gave up waiting after 500 seconds...\n");
	    				System.exit(10);
	    			}
	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834339
net/sf/varscan/CallPileup.java 142 151
net/sf/varscan/VarScan.java 519 529
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
	    		{
	    			System.err.println("Input stream not ready, waiting for 5 seconds...");
	    			Thread.sleep(5000);
	    			num_naps++;

	    			if(num_naps >= 100)
	    			{
	    				System.err.println("ERROR: Gave up waiting after 500 seconds...\n");
	    				System.exit(10);
	    			}
	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834404
net/sf/varscan/ReadCounts.java 126 134
net/sf/varscan/VarScan.java 519 529
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;
			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
	    		}

----------------------------------------
	    		{
	    			System.err.println("Input stream not ready, waiting for 5 seconds...");
	    			Thread.sleep(5000);
	    			num_naps++;

	    			if(num_naps >= 100)
	    			{
	    				System.err.println("ERROR: Gave up waiting after 500 seconds...\n");
	    				System.exit(10);
	    			}
	    		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834341
net/sf/varscan/ProcessSomatic.java 114 125
net/sf/varscan/ProcessSomatic.java 127 136
----------------------------------------
			{
				isVCF = true;
				String nameString = statusFile.replace(".vcf", "");
				System.err.println("Opening output files: " + nameString + ".Somatic.vcf " + nameString + ".Germline.vcf " + nameString + ".LOH.vcf ");
				outSomatic = new PrintStream( new FileOutputStream(nameString + ".Somatic.vcf") );
				outSomaticHC = new PrintStream( new FileOutputStream(nameString + ".Somatic.hc.vcf") );
				outGermline = new PrintStream( new FileOutputStream(nameString + ".Germline.vcf") );
				outGermlineHC = new PrintStream( new FileOutputStream(nameString + ".Germline.hc.vcf") );
				outLOH = new PrintStream( new FileOutputStream(nameString + ".LOH.vcf") );
				outLOHHC = new PrintStream( new FileOutputStream(nameString + ".LOH.hc.vcf") );

			}

----------------------------------------
			{
				System.err.println("Opening output files: " + statusFile + ".Somatic " + statusFile + ".Germline " + statusFile + ".LOH ");
				outSomatic = new PrintStream( new FileOutputStream(statusFile + ".Somatic") );
				outSomaticHC = new PrintStream( new FileOutputStream(statusFile + ".Somatic.hc") );
				outGermline = new PrintStream( new FileOutputStream(statusFile + ".Germline") );
				outGermlineHC = new PrintStream( new FileOutputStream(statusFile + ".Germline.hc") );
				outLOH = new PrintStream( new FileOutputStream(statusFile + ".LOH") );
				outLOHHC = new PrintStream( new FileOutputStream(statusFile + ".LOH.hc") );

			}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834342
net/sf/varscan/ReadCounts.java 303 312
net/sf/varscan/FilterSomatic.java 359 367
----------------------------------------
	    		    {
	    		    	System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
	    				stats.put("numParsingExceptions", (stats.get("numParsingExceptions") + 1));
	    				if(stats.get("numParsingExceptions") >= 5)
	    				{
	    					System.err.println("Too many parsing exceptions encountered; exiting");
	    					return;
	    				}
	    		    	return;
	    		    }

----------------------------------------
	    				{
		    				System.err.println("Parsing Exception on line:\n" + line + "\n" + e.getLocalizedMessage());
		    				stats.put("numParsingExceptions", (stats.get("numParsingExceptions") + 1));
		    				if(stats.get("numParsingExceptions") >= 5)
		    				{
		    					System.err.println("Too many parsing exceptions encountered; exiting");
		    					return;
		    				}
	    				}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834343
net/sf/varscan/FilterSomatic.java 419 447
net/sf/varscan/FilterSomatic.java 477 511
----------------------------------------
    		{
    			BufferedReader in = new BufferedReader(new FileReader(infile));

    			if(in.ready())
    			{
    				while ((line = in.readLine()) != null)
    				{
    					String[] lineContents = line.split("\t");
    					String chrom = lineContents[0];
    					if(chrom.equals("Chrom") || line.startsWith("#"))
    					{
    						// Ignore headers //
    					}
    					else
    					{
	    					String position = lineContents[1];
	    					String indelKey = chrom + "\t" + position;
	    					indels.put(indelKey, Boolean.TRUE);
    					}

    				}
    			}
    			else
    			{
    				System.err.println("Unable to open indels file for reading");
    			}

    			in.close();
    		}

----------------------------------------
    	{
	    	if(in != null && in.ready())
	    	{
	    		// Parse the infile line by line //

	    		while ((line = in.readLine()) != null)
	    		{
	    			lineCounter++;

	    			try
	    			{
		    			String[] lineContents = line.split("\t");
		    			String chrom = lineContents[0];


		    			if(chrom.equals("Chrom") || line.startsWith("#"))
		    			{
		    				// Ignore headers //
		    			}
		    			else
		    			{
			    			int position = Integer.parseInt(lineContents[1]);
	    					String snpKey = chrom + "\t" + position;
	    					snps.put(snpKey, Boolean.TRUE);
		    			}
	    			}
	    			catch(Exception e)
	    			{
	    				// Ignore parsing exceptions for now
	    			}
	    		}

	    		in.close();
	    	}
    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834344
net/sf/varscan/FilterSomatic.java 419 447
net/sf/varscan/FilterSomatic.java 479 510
----------------------------------------
    		{
    			BufferedReader in = new BufferedReader(new FileReader(infile));

    			if(in.ready())
    			{
    				while ((line = in.readLine()) != null)
    				{
    					String[] lineContents = line.split("\t");
    					String chrom = lineContents[0];
    					if(chrom.equals("Chrom") || line.startsWith("#"))
    					{
    						// Ignore headers //
    					}
    					else
    					{
	    					String position = lineContents[1];
	    					String indelKey = chrom + "\t" + position;
	    					indels.put(indelKey, Boolean.TRUE);
    					}

    				}
    			}
    			else
    			{
    				System.err.println("Unable to open indels file for reading");
    			}

    			in.close();
    		}

----------------------------------------
	    	{
	    		// Parse the infile line by line //

	    		while ((line = in.readLine()) != null)
	    		{
	    			lineCounter++;

	    			try
	    			{
		    			String[] lineContents = line.split("\t");
		    			String chrom = lineContents[0];


		    			if(chrom.equals("Chrom") || line.startsWith("#"))
		    			{
		    				// Ignore headers //
		    			}
		    			else
		    			{
			    			int position = Integer.parseInt(lineContents[1]);
	    					String snpKey = chrom + "\t" + position;
	    					snps.put(snpKey, Boolean.TRUE);
		    			}
	    			}
	    			catch(Exception e)
	    			{
	    				// Ignore parsing exceptions for now
	    			}
	    		}

	    		in.close();
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834345
net/sf/varscan/CallMpileup.java 686 729
net/sf/varscan/VarScan.java 1424 1451
----------------------------------------
	    					{
    	    					double refStrandPlus = 0.50;
    	    					double varStrandPlus = 0.50;

    	    					// Calculate strandedness for variant allele //

    	    					if((allReads2plus + allReads2minus) > 0)
    	    						varStrandPlus = (double) allReads2plus / (double) (allReads2plus + allReads2minus);

    	    					// To save time, only calculate p-value if var strandedness is biased //

    	    					if(varStrandPlus < 0.10 || varStrandPlus > 0.90)
    	    					{
    	    						// Calculate strandedness for reference allele if we have 2+ reads //

        	    					if((allReads1plus + allReads1minus) > 1)
        	    					{
        	    						refStrandPlus = (double) allReads1plus / (double) (allReads1plus + allReads1minus);
        	    						strandPvalue = VarScan.getSignificance(allReads1plus, allReads1minus, allReads2plus, allReads2minus);
        	    					}
        	    					// Otherwise, only homozygous-variant reads seen, so compare to a 50/50 distribution //
    	    						else
    	    						{
    	    							// Compare to expected 50/50 distribution //
    	    							int testReads1plus = (int) (allReads2plus + allReads2minus) / 2;
    	    							int testReads1minus = (allReads2plus + allReads2minus) - testReads1plus;
    	    							strandPvalue = VarScan.getSignificance(testReads1plus, testReads1minus, allReads2plus, allReads2minus);
    	    						}

        	    					strandFilterStatus = "Pass:" + varStrandPlus + ":" + allReads1plus + ":" + allReads1minus + ":" + allReads2plus + ":" + allReads2minus + ":" + pvalueFormat.format(strandPvalue);

    	    						// If ref allele had good strandedness, and var allele did not, this may be a failure //
    	    						if(refStrandPlus >= 0.10 && refStrandPlus <= 0.90 && !(varStrandPlus >= 0.10 && varStrandPlus <= 0.90))
    	    						{
    	    							if(strandPvalue < strandPvalueThreshold)
    	    	    					{
    	    	    						strandFilterStatus = "Fail:" + allReads1plus + ":" + allReads1minus + ":" + allReads2plus + ":" + allReads2minus + ":" + pvalueFormat.format(strandPvalue);
    	    	    						numFailStrandFilter++;
    	    	    						failedStrandFilter = true;
    	    	    					}
    	    						}
    	    					}

	    					}

----------------------------------------
		{
			// Calculate strandedness for reference allele if we have 2+ reads //

			if((reads1plus + reads1minus) > 1)
			{
				refStrandPlus = (double) reads1plus / (double) (reads1plus + reads1minus);
				strandPvalue = VarScan.getSignificance(reads1plus, reads1minus, reads2plus, reads2minus);
			}
			// Otherwise, only homozygous-variant reads seen, so compare to a 50/50 distribution //
			else
			{
				// Compare to expected 50/50 distribution //
				int testReads1plus = (int) (reads2plus + reads2minus) / 2;
				int testReads1minus = (reads2plus + reads2minus) - testReads1plus;
				strandPvalue = VarScan.getSignificance(testReads1plus, testReads1minus, reads2plus, reads2minus);
			}

			strandFilterStatus = "Pass:" + varStrandPlus + ":" + reads1plus + ":" + reads1minus + ":" + reads2plus + ":" + reads2minus + ":" + pvalueFormat.format(strandPvalue);

			// If ref allele had good strandedness, and var allele did not, this may be a failure //
			if(refStrandPlus >= 0.10 && refStrandPlus <= 0.90 && !(varStrandPlus >= 0.10 && varStrandPlus <= 0.90))
			{
				if(strandPvalue < strandPvalueThreshold)
				{
					strandFilterStatus = "Fail:" + reads1plus + ":" + reads1minus + ":" + reads2plus + ":" + reads2minus + ":" + pvalueFormat.format(strandPvalue);
				}
			}
		}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834346
net/sf/varscan/VarScan.java 1424 1451
net/sf/varscan/CallMpileup.java 698 727
----------------------------------------
		{
			// Calculate strandedness for reference allele if we have 2+ reads //

			if((reads1plus + reads1minus) > 1)
			{
				refStrandPlus = (double) reads1plus / (double) (reads1plus + reads1minus);
				strandPvalue = VarScan.getSignificance(reads1plus, reads1minus, reads2plus, reads2minus);
			}
			// Otherwise, only homozygous-variant reads seen, so compare to a 50/50 distribution //
			else
			{
				// Compare to expected 50/50 distribution //
				int testReads1plus = (int) (reads2plus + reads2minus) / 2;
				int testReads1minus = (reads2plus + reads2minus) - testReads1plus;
				strandPvalue = VarScan.getSignificance(testReads1plus, testReads1minus, reads2plus, reads2minus);
			}

			strandFilterStatus = "Pass:" + varStrandPlus + ":" + reads1plus + ":" + reads1minus + ":" + reads2plus + ":" + reads2minus + ":" + pvalueFormat.format(strandPvalue);

			// If ref allele had good strandedness, and var allele did not, this may be a failure //
			if(refStrandPlus >= 0.10 && refStrandPlus <= 0.90 && !(varStrandPlus >= 0.10 && varStrandPlus <= 0.90))
			{
				if(strandPvalue < strandPvalueThreshold)
				{
					strandFilterStatus = "Fail:" + reads1plus + ":" + reads1minus + ":" + reads2plus + ":" + reads2minus + ":" + pvalueFormat.format(strandPvalue);
				}
			}
		}

----------------------------------------
    	    					{
    	    						// Calculate strandedness for reference allele if we have 2+ reads //

        	    					if((allReads1plus + allReads1minus) > 1)
        	    					{
        	    						refStrandPlus = (double) allReads1plus / (double) (allReads1plus + allReads1minus);
        	    						strandPvalue = VarScan.getSignificance(allReads1plus, allReads1minus, allReads2plus, allReads2minus);
        	    					}
        	    					// Otherwise, only homozygous-variant reads seen, so compare to a 50/50 distribution //
    	    						else
    	    						{
    	    							// Compare to expected 50/50 distribution //
    	    							int testReads1plus = (int) (allReads2plus + allReads2minus) / 2;
    	    							int testReads1minus = (allReads2plus + allReads2minus) - testReads1plus;
    	    							strandPvalue = VarScan.getSignificance(testReads1plus, testReads1minus, allReads2plus, allReads2minus);
    	    						}

        	    					strandFilterStatus = "Pass:" + varStrandPlus + ":" + allReads1plus + ":" + allReads1minus + ":" + allReads2plus + ":" + allReads2minus + ":" + pvalueFormat.format(strandPvalue);

    	    						// If ref allele had good strandedness, and var allele did not, this may be a failure //
    	    						if(refStrandPlus >= 0.10 && refStrandPlus <= 0.90 && !(varStrandPlus >= 0.10 && varStrandPlus <= 0.90))
    	    						{
    	    							if(strandPvalue < strandPvalueThreshold)
    	    	    					{
    	    	    						strandFilterStatus = "Fail:" + allReads1plus + ":" + allReads1minus + ":" + allReads2plus + ":" + allReads2minus + ":" + pvalueFormat.format(strandPvalue);
    	    	    						numFailStrandFilter++;
    	    	    						failedStrandFilter = true;
    	    	    					}
    	    						}
    	    					}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834347
net/sf/varscan/CallMpileup.java 708 713
net/sf/varscan/VarScan.java 1434 1439
----------------------------------------
    	    						{
    	    							// Compare to expected 50/50 distribution //
    	    							int testReads1plus = (int) (allReads2plus + allReads2minus) / 2;
    	    							int testReads1minus = (allReads2plus + allReads2minus) - testReads1plus;
    	    							strandPvalue = VarScan.getSignificance(testReads1plus, testReads1minus, allReads2plus, allReads2minus);
    	    						}

----------------------------------------
			{
				// Compare to expected 50/50 distribution //
				int testReads1plus = (int) (reads2plus + reads2minus) / 2;
				int testReads1minus = (reads2plus + reads2minus) - testReads1plus;
				strandPvalue = VarScan.getSignificance(testReads1plus, testReads1minus, reads2plus, reads2minus);
			}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834348
net/sf/varscan/CallMpileup.java 719 726
net/sf/varscan/VarScan.java 1445 1450
----------------------------------------
    	    						{
    	    							if(strandPvalue < strandPvalueThreshold)
    	    	    					{
    	    	    						strandFilterStatus = "Fail:" + allReads1plus + ":" + allReads1minus + ":" + allReads2plus + ":" + allReads2minus + ":" + pvalueFormat.format(strandPvalue);
    	    	    						numFailStrandFilter++;
    	    	    						failedStrandFilter = true;
    	    	    					}
    	    						}

----------------------------------------
			{
				if(strandPvalue < strandPvalueThreshold)
				{
					strandFilterStatus = "Fail:" + reads1plus + ":" + reads1minus + ":" + reads2plus + ":" + reads2minus + ":" + pvalueFormat.format(strandPvalue);
				}
			}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834349
net/sf/varscan/VarScan.java 1515 1521
net/sf/varscan/VarScan.java 1533 1538
----------------------------------------
		{
			fisher = new FishersExact(expReads1 + expReads2 + obsReads1 + obsReads2 + fisher_max);
			//pValue = fisher.getTwoTailedP(expReads1, expReads2, obsReads1, obsReads2);
			pValue = fisher.getRightTailedP(expReads1, expReads2, obsReads1, obsReads2);
			fisher_max = fisher_max + 1000;
			num_tries++;
		}

----------------------------------------
			{
				fisher = new FishersExact(expReads1 + expReads2 + obsReads1 + obsReads2 + fisher_max);
				//pValue = fisher.getTwoTailedP(expReads1, expReads2, obsReads1, obsReads2);
				pValue = fisher.getLeftTailedP(expReads1, expReads2, obsReads1, obsReads2);
				fisher_max = fisher_max + 1000;
			}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834350
net/sf/varscan/FpFilter.java 367 381
net/sf/varscan/VarScan.java 1704 1718
----------------------------------------
        	    						{
        	    							isIndel = true;
        	    							// CONVERT INDEL //
        	    							if(cns.contains("/"))
        	    							{
            	    							String[] indelContents = cns.split("/");
            	    							if(indelContents.length > 1)
            	    								alt = indelContents[1];
        	    							}
        	    							else
        	    							{
        	    								alt = cns;
        	    							}

        	    						}

----------------------------------------
	 {
		 if(genotype.contains("/"))
		 {
			 String[] alleles = genotype.split("/");
			 if(!alleles[0].equals(alleles[1]))
				 return(true);
		 }
		 else
		 {
			 if(genotype.equals("M") || genotype.equals("R") || genotype.equals("W") || genotype.equals("S") || genotype.equals("Y") || genotype.equals("K"))
				 return(true);
		 }

		 return(false);
	 }

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834352
net/sf/varscan/VarScan.java 1704 1718
net/sf/varscan/VarScan.java 1727 1741
----------------------------------------
	 {
		 if(genotype.contains("/"))
		 {
			 String[] alleles = genotype.split("/");
			 if(!alleles[0].equals(alleles[1]))
				 return(true);
		 }
		 else
		 {
			 if(genotype.equals("M") || genotype.equals("R") || genotype.equals("W") || genotype.equals("S") || genotype.equals("Y") || genotype.equals("K"))
				 return(true);
		 }

		 return(false);
	 }

----------------------------------------
	 {
		 if(genotype.contains("/"))
		 {
			 String[] alleles = genotype.split("/");
			 if(alleles[0].equals(alleles[1]))
				 return(true);
		 }
		 else
		 {
			 if(genotype.equals("A") || genotype.equals("C") || genotype.equals("G") || genotype.equals("T"))
				 return(true);
		 }

		 return(false);
	 }

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834351
net/sf/varscan/FpFilter.java 367 381
net/sf/varscan/VarScan.java 1727 1741
----------------------------------------
        	    						{
        	    							isIndel = true;
        	    							// CONVERT INDEL //
        	    							if(cns.contains("/"))
        	    							{
            	    							String[] indelContents = cns.split("/");
            	    							if(indelContents.length > 1)
            	    								alt = indelContents[1];
        	    							}
        	    							else
        	    							{
        	    								alt = cns;
        	    							}

        	    						}

----------------------------------------
	 {
		 if(genotype.contains("/"))
		 {
			 String[] alleles = genotype.split("/");
			 if(alleles[0].equals(alleles[1]))
				 return(true);
		 }
		 else
		 {
			 if(genotype.equals("A") || genotype.equals("C") || genotype.equals("G") || genotype.equals("T"))
				 return(true);
		 }

		 return(false);
	 }

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834355
net/sf/varscan/CallPileup.java 141 157
net/sf/varscan/FilterSomatic.java 165 181
----------------------------------------
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834353
net/sf/varscan/CallMpileup.java 233 249
net/sf/varscan/FilterSomatic.java 165 181
----------------------------------------
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834358
net/sf/varscan/Somatic.java 255 271
net/sf/varscan/FilterSomatic.java 165 181
----------------------------------------
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834354
net/sf/varscan/Somatic.java 964 979
net/sf/varscan/FilterSomatic.java 165 181
----------------------------------------
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file(s) were not ready for parsing after 100 5-second cycles! Pileup output may be invalid or too slow");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{

		    	}
	    	}

----------------------------------------
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834356
net/sf/varscan/ProcessSomatic.java 79 95
net/sf/varscan/FilterSomatic.java 165 181
----------------------------------------
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834357
net/sf/varscan/ReadCounts.java 125 139
net/sf/varscan/FilterSomatic.java 165 181
----------------------------------------
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;
			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
	    		}
		    	catch(Exception e)
		    	{

		    	}
	    	}

----------------------------------------
	    	{
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}
		    	catch(Exception e)
		    	{
		    		System.err.println("Exception while trying to get input" + e.getMessage());
		    		System.exit(1);
		    	}
	    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834451
net/sf/varscan/Somatic.java 256 265
net/sf/varscan/FilterSomatic.java 166 175
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834453
net/sf/varscan/ProcessSomatic.java 80 89
net/sf/varscan/FilterSomatic.java 166 175
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834359
net/sf/varscan/CallPileup.java 142 151
net/sf/varscan/FilterSomatic.java 166 175
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834455
net/sf/varscan/ReadCounts.java 126 134
net/sf/varscan/FilterSomatic.java 166 175
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;
			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
	    		}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834452
net/sf/varscan/VarScan.java 519 529
net/sf/varscan/FilterSomatic.java 166 175
----------------------------------------
	    		{
	    			System.err.println("Input stream not ready, waiting for 5 seconds...");
	    			Thread.sleep(5000);
	    			num_naps++;

	    			if(num_naps >= 100)
	    			{
	    				System.err.println("ERROR: Gave up waiting after 500 seconds...\n");
	    				System.exit(10);
	    			}
	    		}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834390
net/sf/varscan/Coverage.java 112 121
net/sf/varscan/FilterSomatic.java 166 175
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 10)
			    	{
			    		System.err.println("Input file was not ready after 10 5-second cycles!");
			    		return;
			    	}
		    	}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834454
net/sf/varscan/Somatic.java 965 974
net/sf/varscan/FilterSomatic.java 166 175
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file(s) were not ready for parsing after 100 5-second cycles! Pileup output may be invalid or too slow");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834450
net/sf/varscan/CallMpileup.java 234 243
net/sf/varscan/FilterSomatic.java 166 175
----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
	    		try {
			    	Thread.sleep(5000);
			    	numNaps++;

			    	if(numNaps > 100)
			    	{
			    		System.err.println("Input file was not ready after 100 5-second cycles!");
			    		System.exit(10);
			    	}
		    	}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834362
net/sf/varscan/LimitVariants.java 232 297
net/sf/varscan/ProcessSomatic.java 365 409
----------------------------------------
	    	{
	    		lineCounter++;
	    		String[] lineContents = line.split("\t");

	    		if(line.substring(0, 1).equals("#"))
	    		{
	    			// Ignore VCF headers //
	    		}
	    		else if(lineContents.length >= 2)
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}
	    	}

----------------------------------------
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834361
net/sf/varscan/LimitVariants.java 244 288
net/sf/varscan/ProcessSomatic.java 365 409
----------------------------------------
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}

----------------------------------------
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834360
net/sf/varscan/LimitVariants.java 241 296
net/sf/varscan/ProcessSomatic.java 365 409
----------------------------------------
	    		{
	    			// Try to parse chrom and position //
	    			try
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}
	    			catch(Exception e)
	    			{
	    				if(lineCounter > 1)
	    					System.err.println("Warning: Unable to parse chrom/position from " + line);
	    			}


	    		}

----------------------------------------
	    			{
	    				String refName = lineContents[0];

	    				// Get or create BitSet for this refName //
	    				BitSet refPositions;

	    				if(positionsByChrom.containsKey(refName))
	    				{
	    					refPositions = positionsByChrom.get(refName);
	    				}
	    				else
	    				{
	    					refPositions = new BitSet();
	    				}

	    				// Mark position or regions, depending on what was provided //
	    				int chrStart = 0;
	    				int chrStop = 0;

	    				if(fileType.equals("positions") && lineContents.length > 1)
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}
	    				else if(fileType.equals("regions") && lineContents.length > 2)
	    				{
	    					chrStart = Integer.parseInt(lineContents[1]) - marginSize;
	    					chrStop = Integer.parseInt(lineContents[2]) + marginSize;
	    				}

    					// Check that it won't be an infinite loop//
    					if(chrStart <= chrStop)
    					{
	    					// Mark every position //
	    					for(int position = chrStart; position <= chrStop; position++)
	    					{
	    						refPositions.set(position, true);
	    					}
    					}

	    				// Return it to the hash //
	    				positionsByChrom.put(refName, refPositions);
	    			}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834363
net/sf/varscan/LimitVariants.java 264 269
net/sf/varscan/ProcessSomatic.java 385 390
----------------------------------------
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}

----------------------------------------
	    				{
		    				// Set the position to true //
		    				int position = Integer.parseInt(lineContents[1]);
		    				chrStart = position - marginSize;
		    				chrStop = position + marginSize;
	    				}

----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
96
22834364
net/sf/varscan/FilterSomatic.java 423 440
net/sf/varscan/FilterSomatic.java 487 502
----------------------------------------
    			{
    				while ((line = in.readLine()) != null)
    				{
    					String[] lineContents = line.split("\t");
    					String chrom = lineContents[0];
    					if(chrom.equals("Chrom") || line.startsWith("#"))
    					{
    						// Ignore headers //
    					}
    					else
    					{
	    					String position = lineContents[1];
	    					String indelKey = chrom + "\t" + position;
	    					indels.put(indelKey, Boolean.TRUE);
    					}

    				}
    			}

----------------------------------------
	    			{
		    			String[] lineContents = line.split("\t");
		    			String chrom = lineContents[0];


		    			if(chrom.equals("Chrom") || line.startsWith("#"))
		    			{
		    				// Ignore headers //
		    			}
		    			else
		    			{
			    			int position = Integer.parseInt(lineContents[1]);
	    					String snpKey = chrom + "\t" + position;
	    					snps.put(snpKey, Boolean.TRUE);
		    			}
	    			}

----------------------------------------
